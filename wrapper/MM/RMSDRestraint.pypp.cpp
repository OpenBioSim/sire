// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 3 License

#include "boost/python.hpp"
#include "RMSDRestraint.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireID/index.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "SireUnits/units.h"

#include "rmsdrestraints.h"

#include <QDebug>

#include "rmsdrestraints.h"

SireMM::RMSDRestraint __copy__(const SireMM::RMSDRestraint &other){ return SireMM::RMSDRestraint(other); }

#include "Helpers/copy.hpp"

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_RMSDRestraint_class(){

    { //::SireMM::RMSDRestraint
        typedef bp::class_< SireMM::RMSDRestraint, bp::bases< SireBase::Property > > RMSDRestraint_exposer_t;
        RMSDRestraint_exposer_t RMSDRestraint_exposer = RMSDRestraint_exposer_t( "RMSDRestraint", "This class provides information about a single RMSD restraint.\nThe restraints are either flat-bottom harmonics or harmonic potentials\n", bp::init< >("Null constructor") );
        bp::scope RMSDRestraint_scope( RMSDRestraint_exposer );
        RMSDRestraint_exposer.def( bp::init< QList< long long > const &, QList< SireMaths::Vector > const &, SireUnits::Dimension::HarmonicBondConstant const &, SireUnits::Dimension::Length const & >(( bp::arg("atoms"), bp::arg("ref_positions"), bp::arg("k"), bp::arg("r0") ), "Construct a restraint that acts on the group of provided atoms") );
        RMSDRestraint_exposer.def( bp::init< SireMM::RMSDRestraint const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMM::RMSDRestraint::atoms
        
            typedef ::QVector< long long > ( ::SireMM::RMSDRestraint::*atoms_function_type)(  ) const;
            atoms_function_type atoms_function_value( &::SireMM::RMSDRestraint::atoms );
            
            RMSDRestraint_exposer.def( 
                "atoms"
                , atoms_function_value
                , bp::release_gil_policy()
                , "Return the atoms involved in the restraint" );
        
        }
        { //::SireMM::RMSDRestraint::isNull
        
            typedef bool ( ::SireMM::RMSDRestraint::*isNull_function_type)(  ) const;
            isNull_function_type isNull_function_value( &::SireMM::RMSDRestraint::isNull );
            
            RMSDRestraint_exposer.def( 
                "isNull"
                , isNull_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMM::RMSDRestraint::k
        
            typedef ::SireUnits::Dimension::HarmonicBondConstant ( ::SireMM::RMSDRestraint::*k_function_type)(  ) const;
            k_function_type k_function_value( &::SireMM::RMSDRestraint::k );
            
            RMSDRestraint_exposer.def( 
                "k"
                , k_function_value
                , bp::release_gil_policy()
                , "Return the force constant for the restraint" );
        
        }
        RMSDRestraint_exposer.def( bp::self != bp::self );
        RMSDRestraint_exposer.def( bp::self + bp::self );
        RMSDRestraint_exposer.def( bp::self + bp::other< SireMM::RMSDRestraints >() );
        { //::SireMM::RMSDRestraint::operator=
        
            typedef ::SireMM::RMSDRestraint & ( ::SireMM::RMSDRestraint::*assign_function_type)( ::SireMM::RMSDRestraint const & ) ;
            assign_function_type assign_function_value( &::SireMM::RMSDRestraint::operator= );
            
            RMSDRestraint_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        RMSDRestraint_exposer.def( bp::self == bp::self );
        { //::SireMM::RMSDRestraint::r0
        
            typedef ::SireUnits::Dimension::Length ( ::SireMM::RMSDRestraint::*r0_function_type)(  ) const;
            r0_function_type r0_function_value( &::SireMM::RMSDRestraint::r0 );
            
            RMSDRestraint_exposer.def( 
                "r0"
                , r0_function_value
                , bp::release_gil_policy()
                , "Return the width of the flat-bottom well. This is zero for a\n  pure harmonic restraint\n" );
        
        }
        { //::SireMM::RMSDRestraint::ref_positions
        
            typedef ::QVector< SireMaths::Vector > ( ::SireMM::RMSDRestraint::*ref_positions_function_type)(  ) const;
            ref_positions_function_type ref_positions_function_value( &::SireMM::RMSDRestraint::ref_positions );
            
            RMSDRestraint_exposer.def( 
                "ref_positions"
                , ref_positions_function_value
                , bp::release_gil_policy()
                , "Return the reference positions" );
        
        }
        { //::SireMM::RMSDRestraint::toString
        
            typedef ::QString ( ::SireMM::RMSDRestraint::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMM::RMSDRestraint::toString );
            
            RMSDRestraint_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMM::RMSDRestraint::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMM::RMSDRestraint::typeName );
            
            RMSDRestraint_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMM::RMSDRestraint::what
        
            typedef char const * ( ::SireMM::RMSDRestraint::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireMM::RMSDRestraint::what );
            
            RMSDRestraint_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        RMSDRestraint_exposer.staticmethod( "typeName" );
        RMSDRestraint_exposer.def( "__copy__", &__copy__<SireMM::RMSDRestraint>);
        RMSDRestraint_exposer.def( "__deepcopy__", &__copy__<SireMM::RMSDRestraint>);
        RMSDRestraint_exposer.def( "clone", &__copy__<SireMM::RMSDRestraint>);
        RMSDRestraint_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMM::RMSDRestraint >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        RMSDRestraint_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMM::RMSDRestraint >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        RMSDRestraint_exposer.def_pickle(sire_pickle_suite< ::SireMM::RMSDRestraint >());
        RMSDRestraint_exposer.def( "__str__", &__str__< ::SireMM::RMSDRestraint > );
        RMSDRestraint_exposer.def( "__repr__", &__str__< ::SireMM::RMSDRestraint > );
    }

}
