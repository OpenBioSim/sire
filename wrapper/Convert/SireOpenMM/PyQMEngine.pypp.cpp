// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 3 License

#include "boost/python.hpp"
#include "PyQMEngine.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireMaths/vector.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "SireVol/triclinicbox.h"

#include "openmm/serialization/SerializationNode.h"

#include "openmm/serialization/SerializationProxy.h"

#include "pyqm.h"

#include <QHash>

#include <QUuid>

#include <mutex>

#include "SireError/errors.h"

#include "SireMaths/vector.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "SireVol/triclinicbox.h"

#include "openmm/serialization/SerializationNode.h"

#include "openmm/serialization/SerializationProxy.h"

#include "pyqm.h"

#include <QHash>

#include <QUuid>

#include <mutex>

SireOpenMM::PyQMEngine __copy__(const SireOpenMM::PyQMEngine &other){ return SireOpenMM::PyQMEngine(other); }

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_PyQMEngine_class(){

    { //::SireOpenMM::PyQMEngine
        typedef bp::class_< SireOpenMM::PyQMEngine, bp::bases< SireBase::Property, SireOpenMM::QMEngine > > PyQMEngine_exposer_t;
        PyQMEngine_exposer_t PyQMEngine_exposer = PyQMEngine_exposer_t( "PyQMEngine", "", bp::init< >("Default constructor.") );
        bp::scope PyQMEngine_scope( PyQMEngine_exposer );
        PyQMEngine_exposer.def( bp::init< bp::api::object, bp::optional< QString, SireUnits::Dimension::Length, int, bool, double > >(( bp::arg("arg0"), bp::arg("method")="", bp::arg("cutoff")=7.5 * SireUnits::angstrom, bp::arg("neighbour_list_frequency")=(int)(0), bp::arg("is_mechanical")=(bool)(false), bp::arg("lambda")=1. ), "Constructor\nPar:am py_object\nA Python object.\n\nPar:am name\nThe name of the callback method. If empty, then the object is\nassumed to be a callable.\n\nPar:am cutoff\nThe ML cutoff distance.\n\nPar:am neighbour_list_frequency\nThe frequency at which the neighbour list is updated. (Number of steps.)\nIf zero, then no neighbour list is used.\n\nPar:am is_mechanical\nA flag to indicate if mechanical embedding is being used.\n\nPar:am lambda\nThe lambda weighting factor. This can be used to interpolate between\npotentials for end-state correction calculations.\n") );
        PyQMEngine_exposer.def( bp::init< SireOpenMM::PyQMEngine const & >(( bp::arg("other") ), "Copy constructor.") );
        { //::SireOpenMM::PyQMEngine::call
        
            typedef ::boost::tuples::tuple< double, QVector< QVector< double > >, QVector< QVector< double > >, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireOpenMM::PyQMEngine::*call_function_type)( ::QVector< int >,::QVector< double >,::QVector< QVector< double > >,::QVector< QVector< double > >,::QVector < int > ) const;
            call_function_type call_function_value( &::SireOpenMM::PyQMEngine::call );
            
            PyQMEngine_exposer.def( 
                "call"
                , call_function_value
                , ( bp::arg("numbers_qm"), bp::arg("charges_mm"), bp::arg("xyz_qm"), bp::arg("xyz_mm"), bp::arg("idx_mm") )
                , bp::release_gil_policy()
                , "Call the callback function.\nPar:am numbers_qm\nA vector of atomic numbers for the atoms in the ML region.\n\nPar:am charges_mm\nA vector of the charges on the MM atoms in mod electron charge.\n\nPar:am xyz_qm\nA vector of positions for the atoms in the ML region in Angstrom.\n\nPar:am xyz_mm\nA vector of positions for the atoms in the MM region in Angstrom.\n\nPar:am idx_mm A vector of indices for the MM atoms in the QM/MM region. Note that len(idx_mm) <= len(charges_mm) since it only contains the indices of the true MM atoms, not link atoms or virtual charges.\n\nReturn:s\nA tuple containing:\n- The energy in kJmol.\n- A vector of forces for the QM atoms in kJmolnm.\n- A vector of forces for the MM atoms in kJmolnm.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::getAtoms
        
            typedef ::QVector< int > ( ::SireOpenMM::PyQMEngine::*getAtoms_function_type)(  ) const;
            getAtoms_function_type getAtoms_function_value( &::SireOpenMM::PyQMEngine::getAtoms );
            
            PyQMEngine_exposer.def( 
                "getAtoms"
                , getAtoms_function_value
                , bp::release_gil_policy()
                , "Get the indices of the atoms in the QM region.\nReturn:s\nA vector of atom indices for the QM region.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::getCallback
        
            typedef ::SireOpenMM::PyQMCallback ( ::SireOpenMM::PyQMEngine::*getCallback_function_type)(  ) const;
            getCallback_function_type getCallback_function_value( &::SireOpenMM::PyQMEngine::getCallback );
            
            PyQMEngine_exposer.def( 
                "getCallback"
                , getCallback_function_value
                , bp::release_gil_policy()
                , "Get the callback object.\nReturn:s\nA Python object that contains the callback function.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::getCharges
        
            typedef ::QVector< double > ( ::SireOpenMM::PyQMEngine::*getCharges_function_type)(  ) const;
            getCharges_function_type getCharges_function_value( &::SireOpenMM::PyQMEngine::getCharges );
            
            PyQMEngine_exposer.def( 
                "getCharges"
                , getCharges_function_value
                , bp::release_gil_policy()
                , "Get the atomic charges of all atoms in the system.\nReturn:s\nA vector of atomic charges for all atoms in the system.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::getCutoff
        
            typedef ::SireUnits::Dimension::Length ( ::SireOpenMM::PyQMEngine::*getCutoff_function_type)(  ) const;
            getCutoff_function_type getCutoff_function_value( &::SireOpenMM::PyQMEngine::getCutoff );
            
            PyQMEngine_exposer.def( 
                "getCutoff"
                , getCutoff_function_value
                , bp::release_gil_policy()
                , "Get the QM cutoff distance.\nReturn:s\nThe QM cutoff distance.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::getIsMechanical
        
            typedef bool ( ::SireOpenMM::PyQMEngine::*getIsMechanical_function_type)(  ) const;
            getIsMechanical_function_type getIsMechanical_function_value( &::SireOpenMM::PyQMEngine::getIsMechanical );
            
            PyQMEngine_exposer.def( 
                "getIsMechanical"
                , getIsMechanical_function_value
                , bp::release_gil_policy()
                , "Get the mechanical embedding flag.\nReturn:s\nA flag to indicate if mechanical embedding is being used.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::getLambda
        
            typedef double ( ::SireOpenMM::PyQMEngine::*getLambda_function_type)(  ) const;
            getLambda_function_type getLambda_function_value( &::SireOpenMM::PyQMEngine::getLambda );
            
            PyQMEngine_exposer.def( 
                "getLambda"
                , getLambda_function_value
                , bp::release_gil_policy()
                , "Get the lambda weighting factor.\nReturn:s\nThe lambda weighting factor.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::getLinkAtoms
        
            typedef ::boost::tuples::tuple< QMap< int, int >, QMap< int, QVector< int > >, QMap< int, double >, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireOpenMM::PyQMEngine::*getLinkAtoms_function_type)(  ) const;
            getLinkAtoms_function_type getLinkAtoms_function_value( &::SireOpenMM::PyQMEngine::getLinkAtoms );
            
            PyQMEngine_exposer.def( 
                "getLinkAtoms"
                , getLinkAtoms_function_value
                , bp::release_gil_policy()
                , "Get the link atoms associated with each QM atom.\nReturn:s\nA tuple containing:\n\nmm1_to_qm\nA dictionary mapping link atom (MM1) indices to the QM atoms to\nwhich they are bonded.\n\nmm1_to_mm2\nA dictionary of link atoms indices (MM1) to a list of the MM\natoms to which they are bonded (MM2).\n\nbond_scale_factors\nA dictionary of link atom indices (MM1) to a list of the bond\nlength scale factors between the QM and MM1 atoms. The scale\nfactors are the ratio of the equilibrium bond lengths for the\nQM-L (QM-link) atom and QM-MM1 atom, i.e. R0(QM-L)  R0(QM-MM1),\ntaken from the MM force field parameters for the molecule.\n\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::getMM2Atoms
        
            typedef ::QVector< int > ( ::SireOpenMM::PyQMEngine::*getMM2Atoms_function_type)(  ) const;
            getMM2Atoms_function_type getMM2Atoms_function_value( &::SireOpenMM::PyQMEngine::getMM2Atoms );
            
            PyQMEngine_exposer.def( 
                "getMM2Atoms"
                , getMM2Atoms_function_value
                , bp::release_gil_policy()
                , "Get the vector of MM2 atoms.\nReturn:s\nA vector of MM2 atom indices.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::getNeighbourListFrequency
        
            typedef int ( ::SireOpenMM::PyQMEngine::*getNeighbourListFrequency_function_type)(  ) const;
            getNeighbourListFrequency_function_type getNeighbourListFrequency_function_value( &::SireOpenMM::PyQMEngine::getNeighbourListFrequency );
            
            PyQMEngine_exposer.def( 
                "getNeighbourListFrequency"
                , getNeighbourListFrequency_function_value
                , bp::release_gil_policy()
                , "Get the neighbour list frequency.\nReturn:s\nThe neighbour list frequency.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::getNumbers
        
            typedef ::QVector< int > ( ::SireOpenMM::PyQMEngine::*getNumbers_function_type)(  ) const;
            getNumbers_function_type getNumbers_function_value( &::SireOpenMM::PyQMEngine::getNumbers );
            
            PyQMEngine_exposer.def( 
                "getNumbers"
                , getNumbers_function_value
                , bp::release_gil_policy()
                , "Get the atomic numbers for the atoms in the QM region.\nReturn:s\nA vector of atomic numbers for the atoms in the QM region.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::operator=
        
            typedef ::SireOpenMM::PyQMEngine & ( ::SireOpenMM::PyQMEngine::*assign_function_type)( ::SireOpenMM::PyQMEngine const & ) ;
            assign_function_type assign_function_value( &::SireOpenMM::PyQMEngine::operator= );
            
            PyQMEngine_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "Assignment operator." );
        
        }
        { //::SireOpenMM::PyQMEngine::setAtoms
        
            typedef void ( ::SireOpenMM::PyQMEngine::*setAtoms_function_type)( ::QVector< int > ) ;
            setAtoms_function_type setAtoms_function_value( &::SireOpenMM::PyQMEngine::setAtoms );
            
            PyQMEngine_exposer.def( 
                "setAtoms"
                , setAtoms_function_value
                , ( bp::arg("atoms") )
                , bp::release_gil_policy()
                , "Set the list of atom indices for the QM region.\nPar:am atoms\nA vector of atom indices for the QM region.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::setCallback
        
            typedef void ( ::SireOpenMM::PyQMEngine::*setCallback_function_type)( ::SireOpenMM::PyQMCallback ) ;
            setCallback_function_type setCallback_function_value( &::SireOpenMM::PyQMEngine::setCallback );
            
            PyQMEngine_exposer.def( 
                "setCallback"
                , setCallback_function_value
                , ( bp::arg("callback") )
                , bp::release_gil_policy()
                , "Set the callback object.\nPar:am callback\nA Python object that contains the callback function.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::setCharges
        
            typedef void ( ::SireOpenMM::PyQMEngine::*setCharges_function_type)( ::QVector< double > ) ;
            setCharges_function_type setCharges_function_value( &::SireOpenMM::PyQMEngine::setCharges );
            
            PyQMEngine_exposer.def( 
                "setCharges"
                , setCharges_function_value
                , ( bp::arg("charges") )
                , bp::release_gil_policy()
                , "Set the atomic charges of all atoms in the system.\nPar:am charges\nA vector of atomic charges for all atoms in the system.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::setCutoff
        
            typedef void ( ::SireOpenMM::PyQMEngine::*setCutoff_function_type)( ::SireUnits::Dimension::Length ) ;
            setCutoff_function_type setCutoff_function_value( &::SireOpenMM::PyQMEngine::setCutoff );
            
            PyQMEngine_exposer.def( 
                "setCutoff"
                , setCutoff_function_value
                , ( bp::arg("cutoff") )
                , bp::release_gil_policy()
                , "Set the QM cutoff distance.\nPar:am cutoff\nThe QM cutoff distance.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::setIsMechanical
        
            typedef void ( ::SireOpenMM::PyQMEngine::*setIsMechanical_function_type)( bool ) ;
            setIsMechanical_function_type setIsMechanical_function_value( &::SireOpenMM::PyQMEngine::setIsMechanical );
            
            PyQMEngine_exposer.def( 
                "setIsMechanical"
                , setIsMechanical_function_value
                , ( bp::arg("is_mechanical") )
                , bp::release_gil_policy()
                , "Set the mechanical embedding flag.\nPar:am is_mechanical\nA flag to indicate if mechanical embedding is being used.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::setLambda
        
            typedef void ( ::SireOpenMM::PyQMEngine::*setLambda_function_type)( double ) ;
            setLambda_function_type setLambda_function_value( &::SireOpenMM::PyQMEngine::setLambda );
            
            PyQMEngine_exposer.def( 
                "setLambda"
                , setLambda_function_value
                , ( bp::arg("lambda") )
                , bp::release_gil_policy()
                , "Set the lambda weighting factor.\nPar:am lambda\nThe lambda weighting factor.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::setLinkAtoms
        
            typedef void ( ::SireOpenMM::PyQMEngine::*setLinkAtoms_function_type)( ::QMap< int, int >,::QMap< int, QVector< int > >,::QMap< int, double > ) ;
            setLinkAtoms_function_type setLinkAtoms_function_value( &::SireOpenMM::PyQMEngine::setLinkAtoms );
            
            PyQMEngine_exposer.def( 
                "setLinkAtoms"
                , setLinkAtoms_function_value
                , ( bp::arg("mm1_to_qm"), bp::arg("mm1_to_mm2"), bp::arg("bond_scale_factors") )
                , bp::release_gil_policy()
                , "Set the link atoms associated with each QM atom.\nPar:am mm1_to_qm\nA dictionary mapping link atom (MM1) indices to the QM atoms to\nwhich they are bonded.\n\nPar:am mm1_to_mm2\nA dictionary of link atoms indices (MM1) to a list of the MM\natoms to which they are bonded (MM2).\n\nPar:am bond_scale_factors\nA dictionary of link atom indices (MM1) to a list of the bond\nlength scale factors between the QM and MM1 atoms. The scale\nfactors are the ratio of the equilibrium bond lengths for the\nQM-L (QM-link) atom and QM-MM1 atom, i.e. R0(QM-L)  R0(QM-MM1),\ntaken from the MM force field parameters for the molecule.\n\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::setNeighbourListFrequency
        
            typedef void ( ::SireOpenMM::PyQMEngine::*setNeighbourListFrequency_function_type)( int ) ;
            setNeighbourListFrequency_function_type setNeighbourListFrequency_function_value( &::SireOpenMM::PyQMEngine::setNeighbourListFrequency );
            
            PyQMEngine_exposer.def( 
                "setNeighbourListFrequency"
                , setNeighbourListFrequency_function_value
                , ( bp::arg("neighbour_list_frequency") )
                , bp::release_gil_policy()
                , "Set the neighbour list frequency.\nPar:am neighbour_list_frequency\nThe neighbour list frequency.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::setNumbers
        
            typedef void ( ::SireOpenMM::PyQMEngine::*setNumbers_function_type)( ::QVector< int > ) ;
            setNumbers_function_type setNumbers_function_value( &::SireOpenMM::PyQMEngine::setNumbers );
            
            PyQMEngine_exposer.def( 
                "setNumbers"
                , setNumbers_function_value
                , ( bp::arg("numbers") )
                , bp::release_gil_policy()
                , "Set the atomic numbers for the atoms in the QM region.\nPar:am numbers\nA vector of atomic numbers for the atoms in the QM region.\n" );
        
        }
        { //::SireOpenMM::PyQMEngine::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireOpenMM::PyQMEngine::typeName );
            
            PyQMEngine_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "Return the C++ name for this class." );
        
        }
        { //::SireOpenMM::PyQMEngine::what
        
            typedef char const * ( ::SireOpenMM::PyQMEngine::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireOpenMM::PyQMEngine::what );
            
            PyQMEngine_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "Return the C++ name for this class." );
        
        }
        PyQMEngine_exposer.staticmethod( "typeName" );
        PyQMEngine_exposer.def( "__copy__", &__copy__);
        PyQMEngine_exposer.def( "__deepcopy__", &__copy__);
        PyQMEngine_exposer.def( "clone", &__copy__);
        PyQMEngine_exposer.def( "__str__", &__str__< ::SireOpenMM::PyQMEngine > );
        PyQMEngine_exposer.def( "__repr__", &__str__< ::SireOpenMM::PyQMEngine > );
    }

}
