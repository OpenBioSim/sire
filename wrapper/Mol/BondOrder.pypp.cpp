// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 3 License

#include "boost/python.hpp"
#include "BondOrder.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "bondorder.h"

#include <QDebug>

#include "bondorder.h"

SireMol::BondOrder __copy__(const SireMol::BondOrder &other){ return SireMol::BondOrder(other); }

#include "Helpers/copy.hpp"

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_BondOrder_class(){

    { //::SireMol::BondOrder
        typedef bp::class_< SireMol::BondOrder, bp::bases< SireBase::Property > > BondOrder_exposer_t;
        BondOrder_exposer_t BondOrder_exposer = BondOrder_exposer_t( "BondOrder", "This class represents a bond type (e.g. single, double etc.)\n\nAuthor: Christopher Woods\n", bp::init< >("Constructor (default is an undefined bond)") );
        bp::scope BondOrder_scope( BondOrder_exposer );
        BondOrder_exposer.def( bp::init< QString const & >(( bp::arg("s") ), "Construct from the passed string") );
        BondOrder_exposer.def( bp::init< SireMol::BondOrder const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMol::BondOrder::aromaticBond
        
            typedef ::SireMol::BondOrder ( *aromaticBond_function_type )(  );
            aromaticBond_function_type aromaticBond_function_value( &::SireMol::BondOrder::aromaticBond );
            
            BondOrder_exposer.def( 
                "aromaticBond"
                , aromaticBond_function_value
                , bp::release_gil_policy()
                , "Return an aromatic bond" );
        
        }
        { //::SireMol::BondOrder::doubleBond
        
            typedef ::SireMol::BondOrder ( *doubleBond_function_type )(  );
            doubleBond_function_type doubleBond_function_value( &::SireMol::BondOrder::doubleBond );
            
            BondOrder_exposer.def( 
                "doubleBond"
                , doubleBond_function_value
                , bp::release_gil_policy()
                , "Return a double bond" );
        
        }
        { //::SireMol::BondOrder::fromRDKit
        
            typedef ::SireMol::BondOrder ( *fromRDKit_function_type )( ::QString const & );
            fromRDKit_function_type fromRDKit_function_value( &::SireMol::BondOrder::fromRDKit );
            
            BondOrder_exposer.def( 
                "fromRDKit"
                , fromRDKit_function_value
                , ( bp::arg("value") )
                , bp::release_gil_policy()
                , "Construct from a string representation of the RDKit type" );
        
        }
        { //::SireMol::BondOrder::fromSDF
        
            typedef ::SireMol::BondOrder ( *fromSDF_function_type )( int );
            fromSDF_function_type fromSDF_function_value( &::SireMol::BondOrder::fromSDF );
            
            BondOrder_exposer.def( 
                "fromSDF"
                , fromSDF_function_value
                , ( bp::arg("value") )
                , bp::release_gil_policy()
                , "Construct from the the passed SDF number" );
        
        }
        { //::SireMol::BondOrder::isAromatic
        
            typedef bool ( ::SireMol::BondOrder::*isAromatic_function_type)(  ) const;
            isAromatic_function_type isAromatic_function_value( &::SireMol::BondOrder::isAromatic );
            
            BondOrder_exposer.def( 
                "isAromatic"
                , isAromatic_function_value
                , bp::release_gil_policy()
                , "Return whether or not this is an aromatic bond" );
        
        }
        { //::SireMol::BondOrder::isDefined
        
            typedef bool ( ::SireMol::BondOrder::*isDefined_function_type)(  ) const;
            isDefined_function_type isDefined_function_value( &::SireMol::BondOrder::isDefined );
            
            BondOrder_exposer.def( 
                "isDefined"
                , isDefined_function_value
                , bp::release_gil_policy()
                , "Return whether or not the bond type is defined" );
        
        }
        { //::SireMol::BondOrder::isDouble
        
            typedef bool ( ::SireMol::BondOrder::*isDouble_function_type)(  ) const;
            isDouble_function_type isDouble_function_value( &::SireMol::BondOrder::isDouble );
            
            BondOrder_exposer.def( 
                "isDouble"
                , isDouble_function_value
                , bp::release_gil_policy()
                , "Return whether or not this is a double bond" );
        
        }
        { //::SireMol::BondOrder::isSingle
        
            typedef bool ( ::SireMol::BondOrder::*isSingle_function_type)(  ) const;
            isSingle_function_type isSingle_function_value( &::SireMol::BondOrder::isSingle );
            
            BondOrder_exposer.def( 
                "isSingle"
                , isSingle_function_value
                , bp::release_gil_policy()
                , "Return whether or not this is a single bond" );
        
        }
        { //::SireMol::BondOrder::isTriple
        
            typedef bool ( ::SireMol::BondOrder::*isTriple_function_type)(  ) const;
            isTriple_function_type isTriple_function_value( &::SireMol::BondOrder::isTriple );
            
            BondOrder_exposer.def( 
                "isTriple"
                , isTriple_function_value
                , bp::release_gil_policy()
                , "Return whether or not this is a triple bond" );
        
        }
        BondOrder_exposer.def( bp::self != bp::self );
        { //::SireMol::BondOrder::operator=
        
            typedef ::SireMol::BondOrder & ( ::SireMol::BondOrder::*assign_function_type)( ::SireMol::BondOrder const & ) ;
            assign_function_type assign_function_value( &::SireMol::BondOrder::operator= );
            
            BondOrder_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        BondOrder_exposer.def( bp::self == bp::self );
        { //::SireMol::BondOrder::singleBond
        
            typedef ::SireMol::BondOrder ( *singleBond_function_type )(  );
            singleBond_function_type singleBond_function_value( &::SireMol::BondOrder::singleBond );
            
            BondOrder_exposer.def( 
                "singleBond"
                , singleBond_function_value
                , bp::release_gil_policy()
                , "Return a single bond" );
        
        }
        { //::SireMol::BondOrder::toRDKit
        
            typedef ::QString ( ::SireMol::BondOrder::*toRDKit_function_type)(  ) const;
            toRDKit_function_type toRDKit_function_value( &::SireMol::BondOrder::toRDKit );
            
            BondOrder_exposer.def( 
                "toRDKit"
                , toRDKit_function_value
                , bp::release_gil_policy()
                , "Return as a string representation of a RDKit bond order" );
        
        }
        { //::SireMol::BondOrder::toSDF
        
            typedef int ( ::SireMol::BondOrder::*toSDF_function_type)(  ) const;
            toSDF_function_type toSDF_function_value( &::SireMol::BondOrder::toSDF );
            
            BondOrder_exposer.def( 
                "toSDF"
                , toSDF_function_value
                , bp::release_gil_policy()
                , "Return the SDF-format value for this bond" );
        
        }
        { //::SireMol::BondOrder::toString
        
            typedef ::QString ( ::SireMol::BondOrder::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMol::BondOrder::toString );
            
            BondOrder_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::BondOrder::tripleBond
        
            typedef ::SireMol::BondOrder ( *tripleBond_function_type )(  );
            tripleBond_function_type tripleBond_function_value( &::SireMol::BondOrder::tripleBond );
            
            BondOrder_exposer.def( 
                "tripleBond"
                , tripleBond_function_value
                , bp::release_gil_policy()
                , "Return a triple bond" );
        
        }
        { //::SireMol::BondOrder::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMol::BondOrder::typeName );
            
            BondOrder_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::BondOrder::undefinedBond
        
            typedef ::SireMol::BondOrder ( *undefinedBond_function_type )(  );
            undefinedBond_function_type undefinedBond_function_value( &::SireMol::BondOrder::undefinedBond );
            
            BondOrder_exposer.def( 
                "undefinedBond"
                , undefinedBond_function_value
                , bp::release_gil_policy()
                , "Return an undefined bond" );
        
        }
        { //::SireMol::BondOrder::value
        
            typedef int ( ::SireMol::BondOrder::*value_function_type)(  ) const;
            value_function_type value_function_value( &::SireMol::BondOrder::value );
            
            BondOrder_exposer.def( 
                "value"
                , value_function_value
                , bp::release_gil_policy()
                , "Return the bond type (0 to number of bonds)\n" );
        
        }
        { //::SireMol::BondOrder::valueAsDouble
        
            typedef double ( ::SireMol::BondOrder::*valueAsDouble_function_type)(  ) const;
            valueAsDouble_function_type valueAsDouble_function_value( &::SireMol::BondOrder::valueAsDouble );
            
            BondOrder_exposer.def( 
                "valueAsDouble"
                , valueAsDouble_function_value
                , bp::release_gil_policy()
                , "Return the bond order as a double precision number. This matches\n  the value that would be returned by RDKit\n" );
        
        }
        BondOrder_exposer.staticmethod( "aromaticBond" );
        BondOrder_exposer.staticmethod( "doubleBond" );
        BondOrder_exposer.staticmethod( "fromRDKit" );
        BondOrder_exposer.staticmethod( "fromSDF" );
        BondOrder_exposer.staticmethod( "singleBond" );
        BondOrder_exposer.staticmethod( "tripleBond" );
        BondOrder_exposer.staticmethod( "typeName" );
        BondOrder_exposer.staticmethod( "undefinedBond" );
        BondOrder_exposer.def( "__copy__", &__copy__<SireMol::BondOrder>);
        BondOrder_exposer.def( "__deepcopy__", &__copy__<SireMol::BondOrder>);
        BondOrder_exposer.def( "clone", &__copy__<SireMol::BondOrder>);
        BondOrder_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMol::BondOrder >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        BondOrder_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMol::BondOrder >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        BondOrder_exposer.def_pickle(sire_pickle_suite< ::SireMol::BondOrder >());
        BondOrder_exposer.def( "__str__", &__str__< ::SireMol::BondOrder > );
        BondOrder_exposer.def( "__repr__", &__str__< ::SireMol::BondOrder > );
    }

}
