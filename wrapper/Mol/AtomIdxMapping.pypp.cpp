// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 3 License

#include "boost/python.hpp"
#include "Helpers/clone_const_reference.hpp"
#include "AtomIdxMapping.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireID/index.h"

#include "SireMol/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "atomidxmapping.h"

#include "moleculeinfodata.h"

#include "atomidxmapping.h"

SireMol::AtomIdxMapping __copy__(const SireMol::AtomIdxMapping &other){ return SireMol::AtomIdxMapping(other); }

#include "Helpers/copy.hpp"

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

#include "Helpers/len.hpp"

void register_AtomIdxMapping_class(){

    { //::SireMol::AtomIdxMapping
        typedef bp::class_< SireMol::AtomIdxMapping, bp::bases< SireBase::Property > > AtomIdxMapping_exposer_t;
        AtomIdxMapping_exposer_t AtomIdxMapping_exposer = AtomIdxMapping_exposer_t( "AtomIdxMapping", "This class holds the mapping from one set of atom indices to another.\nThis enables you to associate, atom by atom, atom indices in one set to\natom indices in another set. This is useful, e.g. for building perturbations,\nor for specifying mappings for alignments or RMSD calculations etc.\n\nThis is mainly designed to provide sufficient information to merge\nproperties together. It lists not just the atoms that map, but\nalso which atoms are the ghost atoms that map (i.e. were created\nas ghost equivalents)\n", bp::init< >("Null constructor") );
        bp::scope AtomIdxMapping_scope( AtomIdxMapping_exposer );
        AtomIdxMapping_exposer.def( bp::init< SireMol::AtomIdxMappingEntry const & >(( bp::arg("entry") ), "Construct from a single entry") );
        AtomIdxMapping_exposer.def( bp::init< QList< SireMol::AtomIdxMappingEntry > const & >(( bp::arg("entries") ), "Construct from a list of entries") );
        AtomIdxMapping_exposer.def( bp::init< SireMol::AtomIdxMapping const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMol::AtomIdxMapping::append
        
            typedef void ( ::SireMol::AtomIdxMapping::*append_function_type)( ::SireMol::AtomIdxMappingEntry const & ) ;
            append_function_type append_function_value( &::SireMol::AtomIdxMapping::append );
            
            AtomIdxMapping_exposer.def( 
                "append"
                , append_function_value
                , ( bp::arg("entry") )
                , bp::release_gil_policy()
                , "Append an entry to the list" );
        
        }
        { //::SireMol::AtomIdxMapping::append
        
            typedef void ( ::SireMol::AtomIdxMapping::*append_function_type)( ::SireMol::AtomIdxMapping const & ) ;
            append_function_type append_function_value( &::SireMol::AtomIdxMapping::append );
            
            AtomIdxMapping_exposer.def( 
                "append"
                , append_function_value
                , ( bp::arg("other") )
                , bp::release_gil_policy()
                , "Append all of the passed entries of other onto this list" );
        
        }
        { //::SireMol::AtomIdxMapping::clear
        
            typedef void ( ::SireMol::AtomIdxMapping::*clear_function_type)(  ) ;
            clear_function_type clear_function_value( &::SireMol::AtomIdxMapping::clear );
            
            AtomIdxMapping_exposer.def( 
                "clear"
                , clear_function_value
                , bp::release_gil_policy()
                , "Clear the list" );
        
        }
        { //::SireMol::AtomIdxMapping::count
        
            typedef int ( ::SireMol::AtomIdxMapping::*count_function_type)(  ) const;
            count_function_type count_function_value( &::SireMol::AtomIdxMapping::count );
            
            AtomIdxMapping_exposer.def( 
                "count"
                , count_function_value
                , bp::release_gil_policy()
                , "Return the count of the list" );
        
        }
        { //::SireMol::AtomIdxMapping::isEmpty
        
            typedef bool ( ::SireMol::AtomIdxMapping::*isEmpty_function_type)(  ) const;
            isEmpty_function_type isEmpty_function_value( &::SireMol::AtomIdxMapping::isEmpty );
            
            AtomIdxMapping_exposer.def( 
                "isEmpty"
                , isEmpty_function_value
                , bp::release_gil_policy()
                , "Return whether or not the list is empty" );
        
        }
        { //::SireMol::AtomIdxMapping::isMappedIn0
        
            typedef bool ( ::SireMol::AtomIdxMapping::*isMappedIn0_function_type)( ::SireMol::AtomIdx const & ) const;
            isMappedIn0_function_type isMappedIn0_function_value( &::SireMol::AtomIdxMapping::isMappedIn0 );
            
            AtomIdxMapping_exposer.def( 
                "isMappedIn0"
                , isMappedIn0_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Return whether or not this atom is mapped in the reference state" );
        
        }
        { //::SireMol::AtomIdxMapping::isMappedIn1
        
            typedef bool ( ::SireMol::AtomIdxMapping::*isMappedIn1_function_type)( ::SireMol::AtomIdx const & ) const;
            isMappedIn1_function_type isMappedIn1_function_value( &::SireMol::AtomIdxMapping::isMappedIn1 );
            
            AtomIdxMapping_exposer.def( 
                "isMappedIn1"
                , isMappedIn1_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Return whether or not this atom is mapped in the perturbed state" );
        
        }
        { //::SireMol::AtomIdxMapping::isMappedInBoth
        
            typedef bool ( ::SireMol::AtomIdxMapping::*isMappedInBoth_function_type)( ::SireMol::AtomIdx const & ) const;
            isMappedInBoth_function_type isMappedInBoth_function_value( &::SireMol::AtomIdxMapping::isMappedInBoth );
            
            AtomIdxMapping_exposer.def( 
                "isMappedInBoth"
                , isMappedInBoth_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Return whether or not this atom is mapped in both end states" );
        
        }
        { //::SireMol::AtomIdxMapping::isUnmappedIn0
        
            typedef bool ( ::SireMol::AtomIdxMapping::*isUnmappedIn0_function_type)( ::SireMol::AtomIdx const & ) const;
            isUnmappedIn0_function_type isUnmappedIn0_function_value( &::SireMol::AtomIdxMapping::isUnmappedIn0 );
            
            AtomIdxMapping_exposer.def( 
                "isUnmappedIn0"
                , isUnmappedIn0_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomIdxMapping::isUnmappedIn1
        
            typedef bool ( ::SireMol::AtomIdxMapping::*isUnmappedIn1_function_type)( ::SireMol::AtomIdx const & ) const;
            isUnmappedIn1_function_type isUnmappedIn1_function_value( &::SireMol::AtomIdxMapping::isUnmappedIn1 );
            
            AtomIdxMapping_exposer.def( 
                "isUnmappedIn1"
                , isUnmappedIn1_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomIdxMapping::isUnmappedInBoth
        
            typedef bool ( ::SireMol::AtomIdxMapping::*isUnmappedInBoth_function_type)( ::SireMol::AtomIdx const & ) const;
            isUnmappedInBoth_function_type isUnmappedInBoth_function_value( &::SireMol::AtomIdxMapping::isUnmappedInBoth );
            
            AtomIdxMapping_exposer.def( 
                "isUnmappedInBoth"
                , isUnmappedInBoth_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Return whether or not this atom is unmapped in both end states" );
        
        }
        { //::SireMol::AtomIdxMapping::map0to1
        
            typedef ::QHash< SireMol::AtomIdx, SireMol::AtomIdx > ( ::SireMol::AtomIdxMapping::*map0to1_function_type)( bool ) const;
            map0to1_function_type map0to1_function_value( &::SireMol::AtomIdxMapping::map0to1 );
            
            AtomIdxMapping_exposer.def( 
                "map0to1"
                , map0to1_function_value
                , ( bp::arg("include_unmapped")=(bool)(false) )
                , "Return the mapping for the atoms that exist in both the reference\n  and perturbed states, from the index of the atom in the merged\n  molecule to the index of the atom in the perturbed molecule.\n  Note - the reference index is the index in the merged molecule.\n\n  If include_unmapped is true, then also include atoms that are\n  unmapped in either end state. In these cases, the reference index\n  will be the index in the merged molecule (so will always be valid)\n  but the perturbed index will be null for atoms that are unmapped\n  in the perturbed state.\n" );
        
        }
        { //::SireMol::AtomIdxMapping::map1to0
        
            typedef ::QHash< SireMol::AtomIdx, SireMol::AtomIdx > ( ::SireMol::AtomIdxMapping::*map1to0_function_type)( bool ) const;
            map1to0_function_type map1to0_function_value( &::SireMol::AtomIdxMapping::map1to0 );
            
            AtomIdxMapping_exposer.def( 
                "map1to0"
                , map1to0_function_value
                , ( bp::arg("include_unmapped")=(bool)(false) )
                , "Return the mapping for the atoms that exist in both the reference\n  and perturbed states, from the index of the atom in the perturbed\n  molecule to the index of the atom in the merged molecule.\n  Note - the reference index is the index in the merged molecule.\n\n  If include_unmapped is true, then also include atoms that are\n  unmapped in either end state. In these cases, the reference index\n  will be the index in the merged molecule (so will always be valid)\n  and atoms that are unmapped in the perturbed state are not\n  included in the returned dictionary.\n" );
        
        }
        { //::SireMol::AtomIdxMapping::mappedCGAtomIdxIn0
        
            typedef ::QList< SireMol::CGAtomIdx > ( ::SireMol::AtomIdxMapping::*mappedCGAtomIdxIn0_function_type)(  ) const;
            mappedCGAtomIdxIn0_function_type mappedCGAtomIdxIn0_function_value( &::SireMol::AtomIdxMapping::mappedCGAtomIdxIn0 );
            
            AtomIdxMapping_exposer.def( 
                "mappedCGAtomIdxIn0"
                , mappedCGAtomIdxIn0_function_value
                , bp::release_gil_policy()
                , "Equivalent of mappedIn0, but return as a CGAtomIdx" );
        
        }
        { //::SireMol::AtomIdxMapping::mappedCGAtomIdxIn1
        
            typedef ::QList< SireMol::CGAtomIdx > ( ::SireMol::AtomIdxMapping::*mappedCGAtomIdxIn1_function_type)(  ) const;
            mappedCGAtomIdxIn1_function_type mappedCGAtomIdxIn1_function_value( &::SireMol::AtomIdxMapping::mappedCGAtomIdxIn1 );
            
            AtomIdxMapping_exposer.def( 
                "mappedCGAtomIdxIn1"
                , mappedCGAtomIdxIn1_function_value
                , bp::release_gil_policy()
                , "Equivalent of mappedIn1, but return as a CGAtomIdx" );
        
        }
        { //::SireMol::AtomIdxMapping::mappedIn0
        
            typedef ::QList< SireMol::AtomIdx > ( ::SireMol::AtomIdxMapping::*mappedIn0_function_type)(  ) const;
            mappedIn0_function_type mappedIn0_function_value( &::SireMol::AtomIdxMapping::mappedIn0 );
            
            AtomIdxMapping_exposer.def( 
                "mappedIn0"
                , mappedIn0_function_value
                , bp::release_gil_policy()
                , "Return the indexes, in the merged molecule, of atoms that\n  are mapped in the reference state (i.e. they exist in the\n  reference state, regardless of whether or not they exist\n  in the perturbed state). Note - these are the indicies of\n  these atoms in the merged molecule, not the reference molecule.\n" );
        
        }
        { //::SireMol::AtomIdxMapping::mappedIn1
        
            typedef ::QList< SireMol::AtomIdx > ( ::SireMol::AtomIdxMapping::*mappedIn1_function_type)(  ) const;
            mappedIn1_function_type mappedIn1_function_value( &::SireMol::AtomIdxMapping::mappedIn1 );
            
            AtomIdxMapping_exposer.def( 
                "mappedIn1"
                , mappedIn1_function_value
                , bp::release_gil_policy()
                , "Return the indexes, in the merged molecule, of atoms that\n  are mapped in the perturbed state (i.e. they exist in the\n  perturbed state, regardless of whether or not they exist\n  in the reference state). Note - these are the indicies of\n  these atoms in the merged molecule, not the perturbed molecule.\n" );
        
        }
        AtomIdxMapping_exposer.def( bp::self != bp::self );
        AtomIdxMapping_exposer.def( bp::self + bp::self );
        AtomIdxMapping_exposer.def( bp::self + bp::other< SireMol::AtomIdxMappingEntry >() );
        { //::SireMol::AtomIdxMapping::operator=
        
            typedef ::SireMol::AtomIdxMapping & ( ::SireMol::AtomIdxMapping::*assign_function_type)( ::SireMol::AtomIdxMapping const & ) ;
            assign_function_type assign_function_value( &::SireMol::AtomIdxMapping::operator= );
            
            AtomIdxMapping_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        AtomIdxMapping_exposer.def( bp::self == bp::self );
        { //::SireMol::AtomIdxMapping::operator[]
        
            typedef ::SireMol::AtomIdxMappingEntry const & ( ::SireMol::AtomIdxMapping::*__getitem___function_type)( int ) const;
            __getitem___function_type __getitem___function_value( &::SireMol::AtomIdxMapping::operator[] );
            
            AtomIdxMapping_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("i") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        { //::SireMol::AtomIdxMapping::remove
        
            typedef void ( ::SireMol::AtomIdxMapping::*remove_function_type)( int ) ;
            remove_function_type remove_function_value( &::SireMol::AtomIdxMapping::remove );
            
            AtomIdxMapping_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "Remove the entry at index i" );
        
        }
        { //::SireMol::AtomIdxMapping::remove
        
            typedef void ( ::SireMol::AtomIdxMapping::*remove_function_type)( ::SireMol::AtomIdx const & ) ;
            remove_function_type remove_function_value( &::SireMol::AtomIdxMapping::remove );
            
            AtomIdxMapping_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Remove the entry for atom atom" );
        
        }
        { //::SireMol::AtomIdxMapping::remove
        
            typedef void ( ::SireMol::AtomIdxMapping::*remove_function_type)( ::SireMol::CGAtomIdx const & ) ;
            remove_function_type remove_function_value( &::SireMol::AtomIdxMapping::remove );
            
            AtomIdxMapping_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Remove the entry for atom atom" );
        
        }
        { //::SireMol::AtomIdxMapping::size
        
            typedef int ( ::SireMol::AtomIdxMapping::*size_function_type)(  ) const;
            size_function_type size_function_value( &::SireMol::AtomIdxMapping::size );
            
            AtomIdxMapping_exposer.def( 
                "size"
                , size_function_value
                , bp::release_gil_policy()
                , "Return the size of the list" );
        
        }
        { //::SireMol::AtomIdxMapping::take
        
            typedef ::SireMol::AtomIdxMappingEntry ( ::SireMol::AtomIdxMapping::*take_function_type)( int ) ;
            take_function_type take_function_value( &::SireMol::AtomIdxMapping::take );
            
            AtomIdxMapping_exposer.def( 
                "take"
                , take_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "Take the entry at index i" );
        
        }
        { //::SireMol::AtomIdxMapping::take
        
            typedef ::SireMol::AtomIdxMappingEntry ( ::SireMol::AtomIdxMapping::*take_function_type)( ::SireMol::AtomIdx const & ) ;
            take_function_type take_function_value( &::SireMol::AtomIdxMapping::take );
            
            AtomIdxMapping_exposer.def( 
                "take"
                , take_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Take the entry for atom atom" );
        
        }
        { //::SireMol::AtomIdxMapping::take
        
            typedef ::SireMol::AtomIdxMappingEntry ( ::SireMol::AtomIdxMapping::*take_function_type)( ::SireMol::CGAtomIdx const & ) ;
            take_function_type take_function_value( &::SireMol::AtomIdxMapping::take );
            
            AtomIdxMapping_exposer.def( 
                "take"
                , take_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Take the entry for atom atom" );
        
        }
        { //::SireMol::AtomIdxMapping::toString
        
            typedef ::QString ( ::SireMol::AtomIdxMapping::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMol::AtomIdxMapping::toString );
            
            AtomIdxMapping_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Convert this object to a string" );
        
        }
        { //::SireMol::AtomIdxMapping::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMol::AtomIdxMapping::typeName );
            
            AtomIdxMapping_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomIdxMapping::unmappedCGAtomIdxIn0
        
            typedef ::QList< SireMol::CGAtomIdx > ( ::SireMol::AtomIdxMapping::*unmappedCGAtomIdxIn0_function_type)(  ) const;
            unmappedCGAtomIdxIn0_function_type unmappedCGAtomIdxIn0_function_value( &::SireMol::AtomIdxMapping::unmappedCGAtomIdxIn0 );
            
            AtomIdxMapping_exposer.def( 
                "unmappedCGAtomIdxIn0"
                , unmappedCGAtomIdxIn0_function_value
                , bp::release_gil_policy()
                , "Equivalent of unmappedIn0, but return as a CGAtomIdx" );
        
        }
        { //::SireMol::AtomIdxMapping::unmappedCGAtomIdxIn1
        
            typedef ::QList< SireMol::CGAtomIdx > ( ::SireMol::AtomIdxMapping::*unmappedCGAtomIdxIn1_function_type)(  ) const;
            unmappedCGAtomIdxIn1_function_type unmappedCGAtomIdxIn1_function_value( &::SireMol::AtomIdxMapping::unmappedCGAtomIdxIn1 );
            
            AtomIdxMapping_exposer.def( 
                "unmappedCGAtomIdxIn1"
                , unmappedCGAtomIdxIn1_function_value
                , bp::release_gil_policy()
                , "Equivalent of unmappedIn1, but return as a CGAtomIdx" );
        
        }
        { //::SireMol::AtomIdxMapping::unmappedIn0
        
            typedef ::QList< SireMol::AtomIdx > ( ::SireMol::AtomIdxMapping::*unmappedIn0_function_type)(  ) const;
            unmappedIn0_function_type unmappedIn0_function_value( &::SireMol::AtomIdxMapping::unmappedIn0 );
            
            AtomIdxMapping_exposer.def( 
                "unmappedIn0"
                , unmappedIn0_function_value
                , bp::release_gil_policy()
                , "Return the indexes, in the merged molecule, of atoms that\n  are not mapped in the reference state (i.e. they only exist\n  in the perturbed state). Note - these are the indicies of these\n  atoms in the merged molecule, not the perturbed molecule.\n" );
        
        }
        { //::SireMol::AtomIdxMapping::unmappedIn1
        
            typedef ::QList< SireMol::AtomIdx > ( ::SireMol::AtomIdxMapping::*unmappedIn1_function_type)(  ) const;
            unmappedIn1_function_type unmappedIn1_function_value( &::SireMol::AtomIdxMapping::unmappedIn1 );
            
            AtomIdxMapping_exposer.def( 
                "unmappedIn1"
                , unmappedIn1_function_value
                , bp::release_gil_policy()
                , "Return the indexes, in the merged molecule, of atoms that\n  are not mapped in the perturbed state (i.e. they only exist\n  in the reference state). Note - these are the indicies of these\n  atoms in the merged molecule, not the reference molecule.\n" );
        
        }
        { //::SireMol::AtomIdxMapping::what
        
            typedef char const * ( ::SireMol::AtomIdxMapping::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireMol::AtomIdxMapping::what );
            
            AtomIdxMapping_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        AtomIdxMapping_exposer.staticmethod( "typeName" );
        AtomIdxMapping_exposer.def( "__copy__", &__copy__<SireMol::AtomIdxMapping>);
        AtomIdxMapping_exposer.def( "__deepcopy__", &__copy__<SireMol::AtomIdxMapping>);
        AtomIdxMapping_exposer.def( "clone", &__copy__<SireMol::AtomIdxMapping>);
        AtomIdxMapping_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMol::AtomIdxMapping >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AtomIdxMapping_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMol::AtomIdxMapping >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AtomIdxMapping_exposer.def_pickle(sire_pickle_suite< ::SireMol::AtomIdxMapping >());
        AtomIdxMapping_exposer.def( "__str__", &__str__< ::SireMol::AtomIdxMapping > );
        AtomIdxMapping_exposer.def( "__repr__", &__str__< ::SireMol::AtomIdxMapping > );
        AtomIdxMapping_exposer.def( "__len__", &__len_size< ::SireMol::AtomIdxMapping > );
    }

}
