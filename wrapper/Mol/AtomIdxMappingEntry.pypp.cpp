// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 3 License

#include "boost/python.hpp"
#include "AtomIdxMappingEntry.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireID/index.h"

#include "SireMol/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "atomidxmapping.h"

#include "moleculeinfodata.h"

#include "atomidxmapping.h"

SireMol::AtomIdxMappingEntry __copy__(const SireMol::AtomIdxMappingEntry &other){ return SireMol::AtomIdxMappingEntry(other); }

#include "Helpers/copy.hpp"

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_AtomIdxMappingEntry_class(){

    { //::SireMol::AtomIdxMappingEntry
        typedef bp::class_< SireMol::AtomIdxMappingEntry > AtomIdxMappingEntry_exposer_t;
        AtomIdxMappingEntry_exposer_t AtomIdxMappingEntry_exposer = AtomIdxMappingEntry_exposer_t( "AtomIdxMappingEntry", "This is an individual mapping for a single atom", bp::init< >("Null constructor") );
        bp::scope AtomIdxMappingEntry_scope( AtomIdxMappingEntry_exposer );
        AtomIdxMappingEntry_exposer.def( bp::init< SireMol::AtomIdx const &, SireMol::AtomIdx const &, SireMol::MoleculeInfoData const &, SireMol::MoleculeInfoData const &, bool >(( bp::arg("index0"), bp::arg("index1"), bp::arg("molinfo0"), bp::arg("molinfo1"), bp::arg("is_unmapped_in_reference") ), "Construct to map from index0 in molinfo0 to index1 in molinfo1.\n  There is no mapping in the perturbed state if index1 is null. There\n  is no mapping in the reference state if is_unmapped_in_reference is true.\n  It is an error to have index0 null, or if you cannot look up\n  index0 in molinfo0 or index1 in molinfo1.\n") );
        AtomIdxMappingEntry_exposer.def( bp::init< SireMol::AtomIdxMappingEntry const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMol::AtomIdxMappingEntry::atomIdx0
        
            typedef ::SireMol::AtomIdx ( ::SireMol::AtomIdxMappingEntry::*atomIdx0_function_type)(  ) const;
            atomIdx0_function_type atomIdx0_function_value( &::SireMol::AtomIdxMappingEntry::atomIdx0 );
            
            AtomIdxMappingEntry_exposer.def( 
                "atomIdx0"
                , atomIdx0_function_value
                , bp::release_gil_policy()
                , "Return the atom index in the reference state. This will always have\n  a value, even if the atom is unmapped in the reference state\n  (this signals that any parameter with this index should be zero)\n" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::atomIdx1
        
            typedef ::SireMol::AtomIdx ( ::SireMol::AtomIdxMappingEntry::*atomIdx1_function_type)(  ) const;
            atomIdx1_function_type atomIdx1_function_value( &::SireMol::AtomIdxMappingEntry::atomIdx1 );
            
            AtomIdxMappingEntry_exposer.def( 
                "atomIdx1"
                , atomIdx1_function_value
                , bp::release_gil_policy()
                , "Return the atom index in the perturbed state, or a null index if\n  the atom is unmapped in the perturbed state" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::cgAtomIdx0
        
            typedef ::SireMol::CGAtomIdx ( ::SireMol::AtomIdxMappingEntry::*cgAtomIdx0_function_type)(  ) const;
            cgAtomIdx0_function_type cgAtomIdx0_function_value( &::SireMol::AtomIdxMappingEntry::cgAtomIdx0 );
            
            AtomIdxMappingEntry_exposer.def( 
                "cgAtomIdx0"
                , cgAtomIdx0_function_value
                , bp::release_gil_policy()
                , "Return the atom index in the reference state. This will always have\n  a value, even if the atom is unmapped in the reference state\n  (this signals that any parameter with this index should be zero)\n" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::cgAtomIdx1
        
            typedef ::SireMol::CGAtomIdx ( ::SireMol::AtomIdxMappingEntry::*cgAtomIdx1_function_type)(  ) const;
            cgAtomIdx1_function_type cgAtomIdx1_function_value( &::SireMol::AtomIdxMappingEntry::cgAtomIdx1 );
            
            AtomIdxMappingEntry_exposer.def( 
                "cgAtomIdx1"
                , cgAtomIdx1_function_value
                , bp::release_gil_policy()
                , "Return the atom index in the perturbed state, or a null index if\n  the atom is unmapped in the perturbed state" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::isMappedIn0
        
            typedef bool ( ::SireMol::AtomIdxMappingEntry::*isMappedIn0_function_type)(  ) const;
            isMappedIn0_function_type isMappedIn0_function_value( &::SireMol::AtomIdxMappingEntry::isMappedIn0 );
            
            AtomIdxMappingEntry_exposer.def( 
                "isMappedIn0"
                , isMappedIn0_function_value
                , bp::release_gil_policy()
                , "Return whether or not this atom is mapped in the reference state" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::isMappedIn1
        
            typedef bool ( ::SireMol::AtomIdxMappingEntry::*isMappedIn1_function_type)(  ) const;
            isMappedIn1_function_type isMappedIn1_function_value( &::SireMol::AtomIdxMappingEntry::isMappedIn1 );
            
            AtomIdxMappingEntry_exposer.def( 
                "isMappedIn1"
                , isMappedIn1_function_value
                , bp::release_gil_policy()
                , "Return whether or not this atom is mapped in the perturbed state" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::isMappedInBoth
        
            typedef bool ( ::SireMol::AtomIdxMappingEntry::*isMappedInBoth_function_type)(  ) const;
            isMappedInBoth_function_type isMappedInBoth_function_value( &::SireMol::AtomIdxMappingEntry::isMappedInBoth );
            
            AtomIdxMappingEntry_exposer.def( 
                "isMappedInBoth"
                , isMappedInBoth_function_value
                , bp::release_gil_policy()
                , "Return whether or not this atom is mapped in both end states" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::isNull
        
            typedef bool ( ::SireMol::AtomIdxMappingEntry::*isNull_function_type)(  ) const;
            isNull_function_type isNull_function_value( &::SireMol::AtomIdxMappingEntry::isNull );
            
            AtomIdxMappingEntry_exposer.def( 
                "isNull"
                , isNull_function_value
                , bp::release_gil_policy()
                , "Return whether or not this is a null entry" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::isUnmappedIn0
        
            typedef bool ( ::SireMol::AtomIdxMappingEntry::*isUnmappedIn0_function_type)(  ) const;
            isUnmappedIn0_function_type isUnmappedIn0_function_value( &::SireMol::AtomIdxMappingEntry::isUnmappedIn0 );
            
            AtomIdxMappingEntry_exposer.def( 
                "isUnmappedIn0"
                , isUnmappedIn0_function_value
                , bp::release_gil_policy()
                , "Return whether or not this atom is unmapped in the reference state" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::isUnmappedIn1
        
            typedef bool ( ::SireMol::AtomIdxMappingEntry::*isUnmappedIn1_function_type)(  ) const;
            isUnmappedIn1_function_type isUnmappedIn1_function_value( &::SireMol::AtomIdxMappingEntry::isUnmappedIn1 );
            
            AtomIdxMappingEntry_exposer.def( 
                "isUnmappedIn1"
                , isUnmappedIn1_function_value
                , bp::release_gil_policy()
                , "Return whether or not this atom is unmapped in the perturbed state" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::isUnmappedInBoth
        
            typedef bool ( ::SireMol::AtomIdxMappingEntry::*isUnmappedInBoth_function_type)(  ) const;
            isUnmappedInBoth_function_type isUnmappedInBoth_function_value( &::SireMol::AtomIdxMappingEntry::isUnmappedInBoth );
            
            AtomIdxMappingEntry_exposer.def( 
                "isUnmappedInBoth"
                , isUnmappedInBoth_function_value
                , bp::release_gil_policy()
                , "Return whether or not this atom is unmapped in both end states" );
        
        }
        AtomIdxMappingEntry_exposer.def( bp::self != bp::self );
        { //::SireMol::AtomIdxMappingEntry::operator=
        
            typedef ::SireMol::AtomIdxMappingEntry & ( ::SireMol::AtomIdxMappingEntry::*assign_function_type)( ::SireMol::AtomIdxMappingEntry const & ) ;
            assign_function_type assign_function_value( &::SireMol::AtomIdxMappingEntry::operator= );
            
            AtomIdxMappingEntry_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        AtomIdxMappingEntry_exposer.def( bp::self == bp::self );
        { //::SireMol::AtomIdxMappingEntry::toString
        
            typedef ::QString ( ::SireMol::AtomIdxMappingEntry::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMol::AtomIdxMappingEntry::toString );
            
            AtomIdxMappingEntry_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Convert this object to a string" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMol::AtomIdxMappingEntry::typeName );
            
            AtomIdxMappingEntry_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomIdxMappingEntry::what
        
            typedef char const * ( ::SireMol::AtomIdxMappingEntry::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireMol::AtomIdxMappingEntry::what );
            
            AtomIdxMappingEntry_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        AtomIdxMappingEntry_exposer.staticmethod( "typeName" );
        AtomIdxMappingEntry_exposer.def( "__copy__", &__copy__<SireMol::AtomIdxMappingEntry>);
        AtomIdxMappingEntry_exposer.def( "__deepcopy__", &__copy__<SireMol::AtomIdxMappingEntry>);
        AtomIdxMappingEntry_exposer.def( "clone", &__copy__<SireMol::AtomIdxMappingEntry>);
        AtomIdxMappingEntry_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMol::AtomIdxMappingEntry >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AtomIdxMappingEntry_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMol::AtomIdxMappingEntry >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AtomIdxMappingEntry_exposer.def_pickle(sire_pickle_suite< ::SireMol::AtomIdxMappingEntry >());
        AtomIdxMappingEntry_exposer.def( "__str__", &__str__< ::SireMol::AtomIdxMappingEntry > );
        AtomIdxMappingEntry_exposer.def( "__repr__", &__str__< ::SireMol::AtomIdxMappingEntry > );
    }

}
