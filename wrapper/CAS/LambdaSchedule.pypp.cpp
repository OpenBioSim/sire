// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 3 License

#include "boost/python.hpp"
#include "Helpers/clone_const_reference.hpp"
#include "LambdaSchedule.pypp.hpp"

namespace bp = boost::python;

#include "SireCAS/values.h"

#include "SireError/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "lambdaschedule.h"

#include "lambdaschedule.h"

SireCAS::LambdaSchedule __copy__(const SireCAS::LambdaSchedule &other){ return SireCAS::LambdaSchedule(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_LambdaSchedule_class(){

    { //::SireCAS::LambdaSchedule
        typedef bp::class_< SireCAS::LambdaSchedule, bp::bases< SireBase::Property > > LambdaSchedule_exposer_t;
        LambdaSchedule_exposer_t LambdaSchedule_exposer = LambdaSchedule_exposer_t( "LambdaSchedule", "This is a schedule that specifies how parameters are changed according\nto a global lambda value. The change can be broken up by sub lever,\nand by stage.\n", bp::init< >("") );
        bp::scope LambdaSchedule_scope( LambdaSchedule_exposer );
        LambdaSchedule_exposer.def( bp::init< SireCAS::LambdaSchedule const & >(( bp::arg("other") ), "") );
        { //::SireCAS::LambdaSchedule::addChargeScaleStages
        
            typedef void ( ::SireCAS::LambdaSchedule::*addChargeScaleStages_function_type)( double ) ;
            addChargeScaleStages_function_type addChargeScaleStages_function_value( &::SireCAS::LambdaSchedule::addChargeScaleStages );
            
            LambdaSchedule_exposer.def( 
                "addChargeScaleStages"
                , addChargeScaleStages_function_value
                , ( bp::arg("scale")=0.20000000000000001 )
                , "Sandwich the current set of stages with a charge-descaling and\n  a charge-scaling stage. This prepends a charge-descaling stage\n  that scales the charge parameter down from `initial` to\n  :gamma:.initial (where :gamma:=`scale`). The charge parameter in all of\n  the exising stages in this schedule are then multiplied\n  by :gamma:. A final charge-rescaling stage is then appended that\n  scales the charge parameter from :gamma:.final to final.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::addChargeScaleStages
        
            typedef void ( ::SireCAS::LambdaSchedule::*addChargeScaleStages_function_type)( ::QString const &,::QString const &,double ) ;
            addChargeScaleStages_function_type addChargeScaleStages_function_value( &::SireCAS::LambdaSchedule::addChargeScaleStages );
            
            LambdaSchedule_exposer.def( 
                "addChargeScaleStages"
                , addChargeScaleStages_function_value
                , ( bp::arg("decharge_name"), bp::arg("recharge_name"), bp::arg("scale")=0.20000000000000001 )
                , "Sandwich the current set of stages with a charge-descaling and\n  a charge-scaling stage. This prepends a charge-descaling stage\n  that scales the charge parameter down from `initial` to\n  :gamma:.initial (where :gamma:=`scale`). The charge parameter in all of\n  the exising stages in this schedule are then multiplied\n  by :gamma:. A final charge-rescaling stage is then appended that\n  scales the charge parameter from :gamma:.final to final.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::addDecoupleStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*addDecoupleStage_function_type)( bool ) ;
            addDecoupleStage_function_type addDecoupleStage_function_value( &::SireCAS::LambdaSchedule::addDecoupleStage );
            
            LambdaSchedule_exposer.def( 
                "addDecoupleStage"
                , addDecoupleStage_function_value
                , ( bp::arg("perturbed_is_decoupled")=(bool)(true) )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::addDecoupleStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*addDecoupleStage_function_type)( ::QString const &,bool ) ;
            addDecoupleStage_function_type addDecoupleStage_function_value( &::SireCAS::LambdaSchedule::addDecoupleStage );
            
            LambdaSchedule_exposer.def( 
                "addDecoupleStage"
                , addDecoupleStage_function_value
                , ( bp::arg("name"), bp::arg("perturbed_is_decoupled")=(bool)(true) )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::addForce
        
            typedef void ( ::SireCAS::LambdaSchedule::*addForce_function_type)( ::QString const & ) ;
            addForce_function_type addForce_function_value( &::SireCAS::LambdaSchedule::addForce );
            
            LambdaSchedule_exposer.def( 
                "addForce"
                , addForce_function_value
                , ( bp::arg("force") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::addForces
        
            typedef void ( ::SireCAS::LambdaSchedule::*addForces_function_type)( ::QStringList const & ) ;
            addForces_function_type addForces_function_value( &::SireCAS::LambdaSchedule::addForces );
            
            LambdaSchedule_exposer.def( 
                "addForces"
                , addForces_function_value
                , ( bp::arg("forces") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::addLever
        
            typedef void ( ::SireCAS::LambdaSchedule::*addLever_function_type)( ::QString const & ) ;
            addLever_function_type addLever_function_value( &::SireCAS::LambdaSchedule::addLever );
            
            LambdaSchedule_exposer.def( 
                "addLever"
                , addLever_function_value
                , ( bp::arg("lever") )
                , bp::release_gil_policy()
                , "Add a lever to the schedule. This is only useful if you want to\n  plot how the equations would affect the lever. Levers will be\n  automatically added by any perturbation run that needs them,\n  so you dont need to add them manually yourself.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::addLevers
        
            typedef void ( ::SireCAS::LambdaSchedule::*addLevers_function_type)( ::QStringList const & ) ;
            addLevers_function_type addLevers_function_value( &::SireCAS::LambdaSchedule::addLevers );
            
            LambdaSchedule_exposer.def( 
                "addLevers"
                , addLevers_function_value
                , ( bp::arg("levers") )
                , bp::release_gil_policy()
                , "Add some levers to the schedule. This is only useful if you want to\n  plot how the equations would affect the lever. Levers will be\n  automatically added by any perturbation run that needs them,\n  so you dont need to add them manually yourself.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::addMorphStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*addMorphStage_function_type)(  ) ;
            addMorphStage_function_type addMorphStage_function_value( &::SireCAS::LambdaSchedule::addMorphStage );
            
            LambdaSchedule_exposer.def( 
                "addMorphStage"
                , addMorphStage_function_value
                , bp::release_gil_policy()
                , "Append a morph stage onto this schedule. The morph stage is a\n  standard stage that scales each forcefield parameter by\n  (1-:lambda:).initial + :lambda:.final\n" );
        
        }
        { //::SireCAS::LambdaSchedule::addMorphStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*addMorphStage_function_type)( ::QString const & ) ;
            addMorphStage_function_type addMorphStage_function_value( &::SireCAS::LambdaSchedule::addMorphStage );
            
            LambdaSchedule_exposer.def( 
                "addMorphStage"
                , addMorphStage_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Append a morph stage onto this schedule. The morph stage is a\n  standard stage that scales each forcefield parameter by\n  (1-:lambda:).initial + :lambda:.final\n" );
        
        }
        { //::SireCAS::LambdaSchedule::addStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*addStage_function_type)( ::QString const &,::SireCAS::Expression const & ) ;
            addStage_function_type addStage_function_value( &::SireCAS::LambdaSchedule::addStage );
            
            LambdaSchedule_exposer.def( 
                "addStage"
                , addStage_function_value
                , ( bp::arg("stage"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "Append a stage called name which uses the passed equation\n  to the end of this schedule. The equation will be the default\n  equation that scales all parameters (levers) that dont have\n  a custom lever for this stage.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::appendStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*appendStage_function_type)( ::QString const &,::SireCAS::Expression const & ) ;
            appendStage_function_type appendStage_function_value( &::SireCAS::LambdaSchedule::appendStage );
            
            LambdaSchedule_exposer.def( 
                "appendStage"
                , appendStage_function_value
                , ( bp::arg("stage"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "Append a stage called name which uses the passed equation\n  to the end of this schedule. The equation will be the default\n  equation that scales all parameters (levers) that dont have\n  a custom lever for this stage.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::charge_scaled_decouple
        
            typedef ::SireCAS::LambdaSchedule ( *charge_scaled_decouple_function_type )( double,bool );
            charge_scaled_decouple_function_type charge_scaled_decouple_function_value( &::SireCAS::LambdaSchedule::charge_scaled_decouple );
            
            LambdaSchedule_exposer.def( 
                "charge_scaled_decouple"
                , charge_scaled_decouple_function_value
                , ( bp::arg("scale")=0.20000000000000001, bp::arg("perturbed_is_decoupled")=(bool)(true) )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::charge_scaled_morph
        
            typedef ::SireCAS::LambdaSchedule ( *charge_scaled_morph_function_type )( double );
            charge_scaled_morph_function_type charge_scaled_morph_function_value( &::SireCAS::LambdaSchedule::charge_scaled_morph );
            
            LambdaSchedule_exposer.def( 
                "charge_scaled_morph"
                , charge_scaled_morph_function_value
                , ( bp::arg("scale")=0.20000000000000001 )
                , "Return a LambdaSchedule that represents a central morph\n  stage that is sandwiched between a charge descaling,\n  and a charge rescaling stage. The first stage scales\n  the charge lever down from 1.0 to `scale`. This\n  is followed by a standard morph stage using the\n  descaled charges. This the finished with a recharging\n  stage that restores the charges back to their\n  original values.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::clamp
        
            typedef double ( ::SireCAS::LambdaSchedule::*clamp_function_type)( double ) const;
            clamp_function_type clamp_function_value( &::SireCAS::LambdaSchedule::clamp );
            
            LambdaSchedule_exposer.def( 
                "clamp"
                , clamp_function_value
                , ( bp::arg("lambda_value") )
                , bp::release_gil_policy()
                , "Clamp and return the passed lambda value so that it is between a valid\n  range for this schedule (typically between [0.0-1.0] inclusive).\n" );
        
        }
        { //::SireCAS::LambdaSchedule::clear
        
            typedef void ( ::SireCAS::LambdaSchedule::*clear_function_type)(  ) ;
            clear_function_type clear_function_value( &::SireCAS::LambdaSchedule::clear );
            
            LambdaSchedule_exposer.def( 
                "clear"
                , clear_function_value
                , bp::release_gil_policy()
                , "Completely clear all stages and levers" );
        
        }
        { //::SireCAS::LambdaSchedule::final
        
            typedef ::SireCAS::Symbol ( *final_function_type )(  );
            final_function_type final_function_value( &::SireCAS::LambdaSchedule::final );
            
            LambdaSchedule_exposer.def( 
                "final"
                , final_function_value
                , bp::release_gil_policy()
                , "Return the symbol used to represent the final\n  (:lambda:=1) value of the forcefield parameter\n" );
        
        }
        { //::SireCAS::LambdaSchedule::getConstant
        
            typedef double ( ::SireCAS::LambdaSchedule::*getConstant_function_type)( ::QString const & ) ;
            getConstant_function_type getConstant_function_value( &::SireCAS::LambdaSchedule::getConstant );
            
            LambdaSchedule_exposer.def( 
                "getConstant"
                , getConstant_function_value
                , ( bp::arg("constant") )
                , bp::release_gil_policy()
                , "Return the value of the passed constant that may be\n  used in any of the stage equations\n" );
        
        }
        { //::SireCAS::LambdaSchedule::getConstant
        
            typedef double ( ::SireCAS::LambdaSchedule::*getConstant_function_type)( ::SireCAS::Symbol const & ) const;
            getConstant_function_type getConstant_function_value( &::SireCAS::LambdaSchedule::getConstant );
            
            LambdaSchedule_exposer.def( 
                "getConstant"
                , getConstant_function_value
                , ( bp::arg("constant") )
                , bp::release_gil_policy()
                , "Return the value of the passed constant that may be\n  used in any of the stage equations\n" );
        
        }
        { //::SireCAS::LambdaSchedule::getConstantSymbol
        
            typedef ::SireCAS::Symbol ( ::SireCAS::LambdaSchedule::*getConstantSymbol_function_type)( ::QString const & ) const;
            getConstantSymbol_function_type getConstantSymbol_function_value( &::SireCAS::LambdaSchedule::getConstantSymbol );
            
            LambdaSchedule_exposer.def( 
                "getConstantSymbol"
                , getConstantSymbol_function_value
                , ( bp::arg("constant") )
                , bp::release_gil_policy()
                , "Get the Symbol used to represent the named constant constant" );
        
        }
        { //::SireCAS::LambdaSchedule::getEquation
        
            typedef ::SireCAS::Expression ( ::SireCAS::LambdaSchedule::*getEquation_function_type)( ::QString const &,::QString const &,::QString const & ) const;
            getEquation_function_type getEquation_function_value( &::SireCAS::LambdaSchedule::getEquation );
            
            LambdaSchedule_exposer.def( 
                "getEquation"
                , getEquation_function_value
                , ( bp::arg("stage")="*", bp::arg("force")="*", bp::arg("lever")="*" )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getForces
        
            typedef ::QStringList ( ::SireCAS::LambdaSchedule::*getForces_function_type)(  ) const;
            getForces_function_type getForces_function_value( &::SireCAS::LambdaSchedule::getForces );
            
            LambdaSchedule_exposer.def( 
                "getForces"
                , getForces_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getLambdaInStage
        
            typedef double ( ::SireCAS::LambdaSchedule::*getLambdaInStage_function_type)( double ) const;
            getLambdaInStage_function_type getLambdaInStage_function_value( &::SireCAS::LambdaSchedule::getLambdaInStage );
            
            LambdaSchedule_exposer.def( 
                "getLambdaInStage"
                , getLambdaInStage_function_value
                , ( bp::arg("lambda_value") )
                , bp::release_gil_policy()
                , "Return the stage-local value of :lambda: that corresponds to the\n  global value of :lambda: at `lambda_value`\n" );
        
        }
        { //::SireCAS::LambdaSchedule::getLeverStages
        
            typedef ::QStringList ( ::SireCAS::LambdaSchedule::*getLeverStages_function_type)( ::QVector< double > const & ) const;
            getLeverStages_function_type getLeverStages_function_value( &::SireCAS::LambdaSchedule::getLeverStages );
            
            LambdaSchedule_exposer.def( 
                "getLeverStages"
                , getLeverStages_function_value
                , ( bp::arg("lambda_values") )
                , bp::release_gil_policy()
                , "Return the list of lever stages that are used for the passed list\n  of lambda values. The lever names will be returned in the matching\n  order of the lambda values.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::getLeverStages
        
            typedef ::QStringList ( ::SireCAS::LambdaSchedule::*getLeverStages_function_type)( int ) const;
            getLeverStages_function_type getLeverStages_function_value( &::SireCAS::LambdaSchedule::getLeverStages );
            
            LambdaSchedule_exposer.def( 
                "getLeverStages"
                , getLeverStages_function_value
                , ( bp::arg("num_lambda")=(int)(101) )
                , "Return the lever stages used for the list of `nvalue` lambda values\n  generated for the global lambda value between 0 and 1 inclusive.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::getLeverValues
        
            typedef ::QHash< QString, QVector< double > > ( ::SireCAS::LambdaSchedule::*getLeverValues_function_type)( ::QVector< double > const &,double,double ) const;
            getLeverValues_function_type getLeverValues_function_value( &::SireCAS::LambdaSchedule::getLeverValues );
            
            LambdaSchedule_exposer.def( 
                "getLeverValues"
                , getLeverValues_function_value
                , ( bp::arg("lambda_values"), bp::arg("initial")=1., bp::arg("final")=2. )
                , "Return the lever name and parameter values for that lever\n  for the specified list of lambda values, assuming that a\n  parameter for that lever has an initial value of\n  `initial_value` and a final value of `final_value`. This\n  is mostly useful for testing and graphing how this\n  schedule would change some hyperthetical forcefield\n  parameters for the specified lambda values.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::getLeverValues
        
            typedef ::QHash< QString, QVector< double > > ( ::SireCAS::LambdaSchedule::*getLeverValues_function_type)( int,double,double ) const;
            getLeverValues_function_type getLeverValues_function_value( &::SireCAS::LambdaSchedule::getLeverValues );
            
            LambdaSchedule_exposer.def( 
                "getLeverValues"
                , getLeverValues_function_value
                , ( bp::arg("num_lambda")=(int)(101), bp::arg("initial")=1., bp::arg("final")=2. )
                , "Return the lever name and parameter values for that lever\n  for the specified number of lambda values generated\n  evenly between 0 and 1, assuming that a\n  parameter for that lever has an initial value of\n  `initial_value` and a final value of `final_value`. This\n  is mostly useful for testing and graphing how this\n  schedule would change some hyperthetical forcefield\n  parameters for the specified lambda values.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::getLevers
        
            typedef ::QStringList ( ::SireCAS::LambdaSchedule::*getLevers_function_type)(  ) const;
            getLevers_function_type getLevers_function_value( &::SireCAS::LambdaSchedule::getLevers );
            
            LambdaSchedule_exposer.def( 
                "getLevers"
                , getLevers_function_value
                , bp::release_gil_policy()
                , "Return all of the levers that have been explicitly added\n  to the schedule. Note that levers will be automatically added\n  by any perturbation run that needs them, so you dont normally\n  need to manage them manually yourself.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::getMoleculeSchedule
        
            typedef ::SireCAS::LambdaSchedule const & ( ::SireCAS::LambdaSchedule::*getMoleculeSchedule_function_type)( int ) const;
            getMoleculeSchedule_function_type getMoleculeSchedule_function_value( &::SireCAS::LambdaSchedule::getMoleculeSchedule );
            
            LambdaSchedule_exposer.def( 
                "getMoleculeSchedule"
                , getMoleculeSchedule_function_value
                , ( bp::arg("pert_mol_id") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getStage
        
            typedef ::QString ( ::SireCAS::LambdaSchedule::*getStage_function_type)( double ) const;
            getStage_function_type getStage_function_value( &::SireCAS::LambdaSchedule::getStage );
            
            LambdaSchedule_exposer.def( 
                "getStage"
                , getStage_function_value
                , ( bp::arg("lambda_value") )
                , bp::release_gil_policy()
                , "Return the name of the stage that controls the forcefield parameters\n  at the global value of :lambda: equal to `lambda_value`\n" );
        
        }
        { //::SireCAS::LambdaSchedule::getStages
        
            typedef ::QStringList ( ::SireCAS::LambdaSchedule::*getStages_function_type)(  ) const;
            getStages_function_type getStages_function_value( &::SireCAS::LambdaSchedule::getStages );
            
            LambdaSchedule_exposer.def( 
                "getStages"
                , getStages_function_value
                , bp::release_gil_policy()
                , "Return the names of all of the stages in this schedule, in\n  the order they will be performed\n" );
        
        }
        { //::SireCAS::LambdaSchedule::hasForceSpecificEquation
        
            typedef bool ( ::SireCAS::LambdaSchedule::*hasForceSpecificEquation_function_type)( ::QString const &,::QString const &,::QString const & ) const;
            hasForceSpecificEquation_function_type hasForceSpecificEquation_function_value( &::SireCAS::LambdaSchedule::hasForceSpecificEquation );
            
            LambdaSchedule_exposer.def( 
                "hasForceSpecificEquation"
                , hasForceSpecificEquation_function_value
                , ( bp::arg("stage")="*", bp::arg("force")="*", bp::arg("lever")="*" )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::hasMoleculeSchedule
        
            typedef bool ( ::SireCAS::LambdaSchedule::*hasMoleculeSchedule_function_type)( int ) const;
            hasMoleculeSchedule_function_type hasMoleculeSchedule_function_value( &::SireCAS::LambdaSchedule::hasMoleculeSchedule );
            
            LambdaSchedule_exposer.def( 
                "hasMoleculeSchedule"
                , hasMoleculeSchedule_function_value
                , ( bp::arg("pert_mol_id") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::initial
        
            typedef ::SireCAS::Symbol ( *initial_function_type )(  );
            initial_function_type initial_function_value( &::SireCAS::LambdaSchedule::initial );
            
            LambdaSchedule_exposer.def( 
                "initial"
                , initial_function_value
                , bp::release_gil_policy()
                , "Return the symbol used to represent the initial\n  (:lambda:=0) value of the forcefield parameter\n" );
        
        }
        { //::SireCAS::LambdaSchedule::insertStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*insertStage_function_type)( int,::QString const &,::SireCAS::Expression const & ) ;
            insertStage_function_type insertStage_function_value( &::SireCAS::LambdaSchedule::insertStage );
            
            LambdaSchedule_exposer.def( 
                "insertStage"
                , insertStage_function_value
                , ( bp::arg("i"), bp::arg("stage"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "Insert a stage called name at position `i` which uses the passed\n  equation. The equation will be the default\n  equation that scales all parameters (levers) that dont have\n  a custom lever for this stage.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::isNull
        
            typedef bool ( ::SireCAS::LambdaSchedule::*isNull_function_type)(  ) const;
            isNull_function_type isNull_function_value( &::SireCAS::LambdaSchedule::isNull );
            
            LambdaSchedule_exposer.def( 
                "isNull"
                , isNull_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::lam
        
            typedef ::SireCAS::Symbol ( *lam_function_type )(  );
            lam_function_type lam_function_value( &::SireCAS::LambdaSchedule::lam );
            
            LambdaSchedule_exposer.def( 
                "lam"
                , lam_function_value
                , bp::release_gil_policy()
                , "Return the symbol used to represent the :lambda: coordinate.\n  This symbol is used to represent the per-stage :lambda:\n  variable that goes from 0.0-1.0 within that stage.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::morph
        
            typedef double ( ::SireCAS::LambdaSchedule::*morph_function_type)( ::QString const &,::QString const &,double,double,double ) const;
            morph_function_type morph_function_value( &::SireCAS::LambdaSchedule::morph );
            
            LambdaSchedule_exposer.def( 
                "morph"
                , morph_function_value
                , ( bp::arg("force")="*", bp::arg("lever")="*", bp::arg("initial")=0, bp::arg("final")=1, bp::arg("lambda_value")=0 )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::morph
        
            typedef ::QVector< double > ( ::SireCAS::LambdaSchedule::*morph_function_type)( ::QString const &,::QString const &,::QVector< double > const &,::QVector< double > const &,double ) const;
            morph_function_type morph_function_value( &::SireCAS::LambdaSchedule::morph );
            
            LambdaSchedule_exposer.def( 
                "morph"
                , morph_function_value
                , ( bp::arg("force")="*", bp::arg("lever")="*", bp::arg("initial")=::QVector<double>( ), bp::arg("final")=::QVector<double>( ), bp::arg("lambda_value")=0. )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::morph
        
            typedef ::QVector< int > ( ::SireCAS::LambdaSchedule::*morph_function_type)( ::QString const &,::QString const &,::QVector< int > const &,::QVector< int > const &,double ) const;
            morph_function_type morph_function_value( &::SireCAS::LambdaSchedule::morph );
            
            LambdaSchedule_exposer.def( 
                "morph"
                , morph_function_value
                , ( bp::arg("force")="*", bp::arg("lever")="*", bp::arg("initial")=::QVector<int>( ), bp::arg("final")=::QVector<int>( ), bp::arg("lambda_value")=0. )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::nForces
        
            typedef int ( ::SireCAS::LambdaSchedule::*nForces_function_type)(  ) const;
            nForces_function_type nForces_function_value( &::SireCAS::LambdaSchedule::nForces );
            
            LambdaSchedule_exposer.def( 
                "nForces"
                , nForces_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::nLevers
        
            typedef int ( ::SireCAS::LambdaSchedule::*nLevers_function_type)(  ) const;
            nLevers_function_type nLevers_function_value( &::SireCAS::LambdaSchedule::nLevers );
            
            LambdaSchedule_exposer.def( 
                "nLevers"
                , nLevers_function_value
                , bp::release_gil_policy()
                , "Return the number of levers that have been explicitly added\n  to the schedule. Note that levers will be automatically added\n  by any perturbation run that needs them, so you dont normally\n  need to manage them manually yourself.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::nStages
        
            typedef int ( ::SireCAS::LambdaSchedule::*nStages_function_type)(  ) const;
            nStages_function_type nStages_function_value( &::SireCAS::LambdaSchedule::nStages );
            
            LambdaSchedule_exposer.def( 
                "nStages"
                , nStages_function_value
                , bp::release_gil_policy()
                , "Return the number of stages in this schedule" );
        
        }
        LambdaSchedule_exposer.def( bp::self != bp::self );
        { //::SireCAS::LambdaSchedule::operator=
        
            typedef ::SireCAS::LambdaSchedule & ( ::SireCAS::LambdaSchedule::*assign_function_type)( ::SireCAS::LambdaSchedule const & ) ;
            assign_function_type assign_function_value( &::SireCAS::LambdaSchedule::operator= );
            
            LambdaSchedule_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        LambdaSchedule_exposer.def( bp::self == bp::self );
        { //::SireCAS::LambdaSchedule::prependStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*prependStage_function_type)( ::QString const &,::SireCAS::Expression const & ) ;
            prependStage_function_type prependStage_function_value( &::SireCAS::LambdaSchedule::prependStage );
            
            LambdaSchedule_exposer.def( 
                "prependStage"
                , prependStage_function_value
                , ( bp::arg("stage"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "Prepend a stage called name which uses the passed equation\n  to the start of this schedule. The equation will be the default\n  equation that scales all parameters (levers) that dont have\n  a custom lever for this stage.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::removeEquation
        
            typedef void ( ::SireCAS::LambdaSchedule::*removeEquation_function_type)( ::QString const &,::QString const &,::QString const & ) ;
            removeEquation_function_type removeEquation_function_value( &::SireCAS::LambdaSchedule::removeEquation );
            
            LambdaSchedule_exposer.def( 
                "removeEquation"
                , removeEquation_function_value
                , ( bp::arg("stage")="*", bp::arg("force")="*", bp::arg("lever")="*" )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::removeForce
        
            typedef void ( ::SireCAS::LambdaSchedule::*removeForce_function_type)( ::QString const & ) ;
            removeForce_function_type removeForce_function_value( &::SireCAS::LambdaSchedule::removeForce );
            
            LambdaSchedule_exposer.def( 
                "removeForce"
                , removeForce_function_value
                , ( bp::arg("force") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::removeForces
        
            typedef void ( ::SireCAS::LambdaSchedule::*removeForces_function_type)( ::QStringList const & ) ;
            removeForces_function_type removeForces_function_value( &::SireCAS::LambdaSchedule::removeForces );
            
            LambdaSchedule_exposer.def( 
                "removeForces"
                , removeForces_function_value
                , ( bp::arg("forces") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::removeLever
        
            typedef void ( ::SireCAS::LambdaSchedule::*removeLever_function_type)( ::QString const & ) ;
            removeLever_function_type removeLever_function_value( &::SireCAS::LambdaSchedule::removeLever );
            
            LambdaSchedule_exposer.def( 
                "removeLever"
                , removeLever_function_value
                , ( bp::arg("lever") )
                , bp::release_gil_policy()
                , "Remove a lever from the schedule. This will not impact any\n  perturbation runs that use this schedule, as any missing\n  levers will be re-added.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::removeLevers
        
            typedef void ( ::SireCAS::LambdaSchedule::*removeLevers_function_type)( ::QStringList const & ) ;
            removeLevers_function_type removeLevers_function_value( &::SireCAS::LambdaSchedule::removeLevers );
            
            LambdaSchedule_exposer.def( 
                "removeLevers"
                , removeLevers_function_value
                , ( bp::arg("levers") )
                , bp::release_gil_policy()
                , "Remove some levers from the schedule. This will not impact any\n  perturbation runs that use this schedule, as any missing\n  levers will be re-added.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::removeMoleculeSchedule
        
            typedef void ( ::SireCAS::LambdaSchedule::*removeMoleculeSchedule_function_type)( int ) ;
            removeMoleculeSchedule_function_type removeMoleculeSchedule_function_value( &::SireCAS::LambdaSchedule::removeMoleculeSchedule );
            
            LambdaSchedule_exposer.def( 
                "removeMoleculeSchedule"
                , removeMoleculeSchedule_function_value
                , ( bp::arg("pert_mol_id") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::removeStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*removeStage_function_type)( ::QString const & ) ;
            removeStage_function_type removeStage_function_value( &::SireCAS::LambdaSchedule::removeStage );
            
            LambdaSchedule_exposer.def( 
                "removeStage"
                , removeStage_function_value
                , ( bp::arg("stage") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::setConstant
        
            typedef ::SireCAS::Symbol ( ::SireCAS::LambdaSchedule::*setConstant_function_type)( ::QString const &,double ) ;
            setConstant_function_type setConstant_function_value( &::SireCAS::LambdaSchedule::setConstant );
            
            LambdaSchedule_exposer.def( 
                "setConstant"
                , setConstant_function_value
                , ( bp::arg("constant"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the value of a constant that may be used in any\n  of the stage equations.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::setConstant
        
            typedef ::SireCAS::Symbol ( ::SireCAS::LambdaSchedule::*setConstant_function_type)( ::SireCAS::Symbol const &,double ) ;
            setConstant_function_type setConstant_function_value( &::SireCAS::LambdaSchedule::setConstant );
            
            LambdaSchedule_exposer.def( 
                "setConstant"
                , setConstant_function_value
                , ( bp::arg("constant"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the value of a constant that may be used in any\n  of the stage equations.\n" );
        
        }
        { //::SireCAS::LambdaSchedule::setDefaultStageEquation
        
            typedef void ( ::SireCAS::LambdaSchedule::*setDefaultStageEquation_function_type)( ::QString const &,::SireCAS::Expression const & ) ;
            setDefaultStageEquation_function_type setDefaultStageEquation_function_value( &::SireCAS::LambdaSchedule::setDefaultStageEquation );
            
            LambdaSchedule_exposer.def( 
                "setDefaultStageEquation"
                , setDefaultStageEquation_function_value
                , ( bp::arg("stage"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::setEquation
        
            typedef void ( ::SireCAS::LambdaSchedule::*setEquation_function_type)( ::QString const &,::QString const &,::QString const &,::SireCAS::Expression const & ) ;
            setEquation_function_type setEquation_function_value( &::SireCAS::LambdaSchedule::setEquation );
            
            LambdaSchedule_exposer.def( 
                "setEquation"
                , setEquation_function_value
                , ( bp::arg("stage")="*", bp::arg("force")="*", bp::arg("lever")="*", bp::arg("equation")=SireCAS::Expression() )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::setMoleculeSchedule
        
            typedef void ( ::SireCAS::LambdaSchedule::*setMoleculeSchedule_function_type)( int,::SireCAS::LambdaSchedule const & ) ;
            setMoleculeSchedule_function_type setMoleculeSchedule_function_value( &::SireCAS::LambdaSchedule::setMoleculeSchedule );
            
            LambdaSchedule_exposer.def( 
                "setMoleculeSchedule"
                , setMoleculeSchedule_function_value
                , ( bp::arg("pert_mol_id"), bp::arg("schedule") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::standard_decouple
        
            typedef ::SireCAS::LambdaSchedule ( *standard_decouple_function_type )( bool );
            standard_decouple_function_type standard_decouple_function_value( &::SireCAS::LambdaSchedule::standard_decouple );
            
            LambdaSchedule_exposer.def( 
                "standard_decouple"
                , standard_decouple_function_value
                , ( bp::arg("perturbed_is_decoupled")=(bool)(true) )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::standard_morph
        
            typedef ::SireCAS::LambdaSchedule ( *standard_morph_function_type )(  );
            standard_morph_function_type standard_morph_function_value( &::SireCAS::LambdaSchedule::standard_morph );
            
            LambdaSchedule_exposer.def( 
                "standard_morph"
                , standard_morph_function_value
                , bp::release_gil_policy()
                , "Return a LambdaSchedule that represents a standard morph,\n  where every forcefield parameter is scaled by\n  (1-:lambda:).initial + :lambda:.final\n" );
        
        }
        { //::SireCAS::LambdaSchedule::takeMoleculeSchedule
        
            typedef ::SireCAS::LambdaSchedule ( ::SireCAS::LambdaSchedule::*takeMoleculeSchedule_function_type)( int ) ;
            takeMoleculeSchedule_function_type takeMoleculeSchedule_function_value( &::SireCAS::LambdaSchedule::takeMoleculeSchedule );
            
            LambdaSchedule_exposer.def( 
                "takeMoleculeSchedule"
                , takeMoleculeSchedule_function_value
                , ( bp::arg("pert_mol_id") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::toString
        
            typedef ::QString ( ::SireCAS::LambdaSchedule::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireCAS::LambdaSchedule::toString );
            
            LambdaSchedule_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireCAS::LambdaSchedule::typeName );
            
            LambdaSchedule_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::what
        
            typedef char const * ( ::SireCAS::LambdaSchedule::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireCAS::LambdaSchedule::what );
            
            LambdaSchedule_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        LambdaSchedule_exposer.staticmethod( "charge_scaled_decouple" );
        LambdaSchedule_exposer.staticmethod( "charge_scaled_morph" );
        LambdaSchedule_exposer.staticmethod( "final" );
        LambdaSchedule_exposer.staticmethod( "initial" );
        LambdaSchedule_exposer.staticmethod( "lam" );
        LambdaSchedule_exposer.staticmethod( "standard_decouple" );
        LambdaSchedule_exposer.staticmethod( "standard_morph" );
        LambdaSchedule_exposer.staticmethod( "typeName" );
        LambdaSchedule_exposer.def( "__copy__", &__copy__);
        LambdaSchedule_exposer.def( "__deepcopy__", &__copy__);
        LambdaSchedule_exposer.def( "clone", &__copy__);
        LambdaSchedule_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireCAS::LambdaSchedule >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        LambdaSchedule_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireCAS::LambdaSchedule >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        LambdaSchedule_exposer.def_pickle(sire_pickle_suite< ::SireCAS::LambdaSchedule >());
        LambdaSchedule_exposer.def( "__str__", &__str__< ::SireCAS::LambdaSchedule > );
        LambdaSchedule_exposer.def( "__repr__", &__str__< ::SireCAS::LambdaSchedule > );
    }

}
