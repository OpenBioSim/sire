// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 3 License

#include "boost/python.hpp"
#include "AmberTraj.pypp.hpp"

namespace bp = boost::python;

#include "SireBase/generalunitproperty.h"

#include "SireBase/parallel.h"

#include "SireBase/progressbar.h"

#include "SireBase/releasegil.h"

#include "SireBase/stringproperty.h"

#include "SireBase/timeproperty.h"

#include "SireError/errors.h"

#include "SireIO/amberformat.h"

#include "SireIO/ambertraj.h"

#include "SireIO/errors.h"

#include "SireIO/textfile.h"

#include "SireMol/atomcoords.h"

#include "SireMol/atomvelocities.h"

#include "SireMol/core.h"

#include "SireMol/mgname.h"

#include "SireMol/molecule.h"

#include "SireMol/moleditor.h"

#include "SireMol/molidx.h"

#include "SireMol/trajectory.h"

#include "SireStream/shareddatastream.h"

#include "SireSystem/system.h"

#include "SireUnits/dimensions.h"

#include "SireUnits/units.h"

#include "SireVol/periodicbox.h"

#include "SireVol/triclinicbox.h"

#include "ambertraj.h"

#include <QFile>

#include <QTextStream>

#include "ambertraj.h"

SireIO::AmberTraj __copy__(const SireIO::AmberTraj &other){ return SireIO::AmberTraj(other); }

#include "Helpers/copy.hpp"

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_AmberTraj_class(){

    { //::SireIO::AmberTraj
        typedef bp::class_< SireIO::AmberTraj, bp::bases< SireIO::MoleculeParser, SireBase::Property > > AmberTraj_exposer_t;
        AmberTraj_exposer_t AmberTraj_exposer = AmberTraj_exposer_t( "AmberTraj", "This class represents an Amber-format trajectory file (ascii)\ncurrently supporting these files from Amber7 to Amber16.\n\nThis file holds either coordinates OR velocities (but not both).\nIt can hold box information, but not time information.\n\nIt holds the coordinates or velocities as a dense block of\nascii numbers. It is described in the amber manual under\nAMBER trajectory (coordinate or velocity) file specification\n\nhttps:ambermd.orgFileFormats.php#trajectory\n", bp::init< >("Constructor") );
        bp::scope AmberTraj_scope( AmberTraj_exposer );
        AmberTraj_exposer.def( bp::init< QString const &, bp::optional< SireBase::PropertyMap const & > >(( bp::arg("filename"), bp::arg("map")=SireBase::PropertyMap() ), "Construct by parsing the data in the passed text lines") );
        AmberTraj_exposer.def( bp::init< QStringList const &, bp::optional< SireBase::PropertyMap const & > >(( bp::arg("lines"), bp::arg("map")=SireBase::PropertyMap() ), "Construct by parsing the data in the passed text lines") );
        AmberTraj_exposer.def( bp::init< SireSystem::System const &, bp::optional< SireBase::PropertyMap const & > >(( bp::arg("system"), bp::arg("map")=SireBase::PropertyMap() ), "Construct by extracting the necessary data from the passed System") );
        AmberTraj_exposer.def( bp::init< SireIO::AmberTraj const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireIO::AmberTraj::construct
        
            typedef ::SireIO::MoleculeParserPtr ( ::SireIO::AmberTraj::*construct_function_type)( ::QString const &,::SireBase::PropertyMap const & ) const;
            construct_function_type construct_function_value( &::SireIO::AmberTraj::construct );
            
            AmberTraj_exposer.def( 
                "construct"
                , construct_function_value
                , ( bp::arg("filename"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Return this parser constructed from the passed filename" );
        
        }
        { //::SireIO::AmberTraj::construct
        
            typedef ::SireIO::MoleculeParserPtr ( ::SireIO::AmberTraj::*construct_function_type)( ::QStringList const &,::SireBase::PropertyMap const & ) const;
            construct_function_type construct_function_value( &::SireIO::AmberTraj::construct );
            
            AmberTraj_exposer.def( 
                "construct"
                , construct_function_value
                , ( bp::arg("lines"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Return this parser constructed from the passed set of lines" );
        
        }
        { //::SireIO::AmberTraj::construct
        
            typedef ::SireIO::MoleculeParserPtr ( ::SireIO::AmberTraj::*construct_function_type)( ::SireSystem::System const &,::SireBase::PropertyMap const & ) const;
            construct_function_type construct_function_value( &::SireIO::AmberTraj::construct );
            
            AmberTraj_exposer.def( 
                "construct"
                , construct_function_value
                , ( bp::arg("system"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Return this parser constructed from the passed SireSystem::System" );
        
        }
        { //::SireIO::AmberTraj::formatDescription
        
            typedef ::QString ( ::SireIO::AmberTraj::*formatDescription_function_type)(  ) const;
            formatDescription_function_type formatDescription_function_value( &::SireIO::AmberTraj::formatDescription );
            
            AmberTraj_exposer.def( 
                "formatDescription"
                , formatDescription_function_value
                , bp::release_gil_policy()
                , "Return a description of the file format" );
        
        }
        { //::SireIO::AmberTraj::formatName
        
            typedef ::QString ( ::SireIO::AmberTraj::*formatName_function_type)(  ) const;
            formatName_function_type formatName_function_value( &::SireIO::AmberTraj::formatName );
            
            AmberTraj_exposer.def( 
                "formatName"
                , formatName_function_value
                , bp::release_gil_policy()
                , "Return the format name that is used to identify this file format within Sire" );
        
        }
        { //::SireIO::AmberTraj::formatSuffix
        
            typedef ::QStringList ( ::SireIO::AmberTraj::*formatSuffix_function_type)(  ) const;
            formatSuffix_function_type formatSuffix_function_value( &::SireIO::AmberTraj::formatSuffix );
            
            AmberTraj_exposer.def( 
                "formatSuffix"
                , formatSuffix_function_value
                , bp::release_gil_policy()
                , "Return the suffixes that RST7 files will typically have" );
        
        }
        { //::SireIO::AmberTraj::getFrame
        
            typedef ::SireMol::Frame ( ::SireIO::AmberTraj::*getFrame_function_type)( int ) const;
            getFrame_function_type getFrame_function_value( &::SireIO::AmberTraj::getFrame );
            
            AmberTraj_exposer.def( 
                "getFrame"
                , getFrame_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireIO::AmberTraj::isFrame
        
            typedef bool ( ::SireIO::AmberTraj::*isFrame_function_type)(  ) const;
            isFrame_function_type isFrame_function_value( &::SireIO::AmberTraj::isFrame );
            
            AmberTraj_exposer.def( 
                "isFrame"
                , isFrame_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireIO::AmberTraj::isTextFile
        
            typedef bool ( ::SireIO::AmberTraj::*isTextFile_function_type)(  ) const;
            isTextFile_function_type isTextFile_function_value( &::SireIO::AmberTraj::isTextFile );
            
            AmberTraj_exposer.def( 
                "isTextFile"
                , isTextFile_function_value
                , bp::release_gil_policy()
                , "This is not a text file that should be cached\n  (it is potentially massive)\n" );
        
        }
        { //::SireIO::AmberTraj::nAtoms
        
            typedef int ( ::SireIO::AmberTraj::*nAtoms_function_type)(  ) const;
            nAtoms_function_type nAtoms_function_value( &::SireIO::AmberTraj::nAtoms );
            
            AmberTraj_exposer.def( 
                "nAtoms"
                , nAtoms_function_value
                , bp::release_gil_policy()
                , "Return the number of atoms whose coordinates are contained in this restart file" );
        
        }
        { //::SireIO::AmberTraj::nFrames
        
            typedef int ( ::SireIO::AmberTraj::*nFrames_function_type)(  ) const;
            nFrames_function_type nFrames_function_value( &::SireIO::AmberTraj::nFrames );
            
            AmberTraj_exposer.def( 
                "nFrames"
                , nFrames_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        AmberTraj_exposer.def( bp::self != bp::self );
        { //::SireIO::AmberTraj::operator=
        
            typedef ::SireIO::AmberTraj & ( ::SireIO::AmberTraj::*assign_function_type)( ::SireIO::AmberTraj const & ) ;
            assign_function_type assign_function_value( &::SireIO::AmberTraj::operator= );
            
            AmberTraj_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        AmberTraj_exposer.def( bp::self == bp::self );
        { //::SireIO::AmberTraj::operator[]
        
            typedef ::SireIO::AmberTraj ( ::SireIO::AmberTraj::*__getitem___function_type)( int ) const;
            __getitem___function_type __getitem___function_value( &::SireIO::AmberTraj::operator[] );
            
            AmberTraj_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("i") )
                , "" );
        
        }
        { //::SireIO::AmberTraj::parse
        
            typedef ::SireIO::AmberTraj ( *parse_function_type )( ::QString const & );
            parse_function_type parse_function_value( &::SireIO::AmberTraj::parse );
            
            AmberTraj_exposer.def( 
                "parse"
                , parse_function_value
                , ( bp::arg("filename") )
                , bp::release_gil_policy()
                , "Parse from the passed file" );
        
        }
        { //::SireIO::AmberTraj::title
        
            typedef ::QString ( ::SireIO::AmberTraj::*title_function_type)(  ) const;
            title_function_type title_function_value( &::SireIO::AmberTraj::title );
            
            AmberTraj_exposer.def( 
                "title"
                , title_function_value
                , bp::release_gil_policy()
                , "Return the title of the file" );
        
        }
        { //::SireIO::AmberTraj::toString
        
            typedef ::QString ( ::SireIO::AmberTraj::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireIO::AmberTraj::toString );
            
            AmberTraj_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireIO::AmberTraj::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireIO::AmberTraj::typeName );
            
            AmberTraj_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireIO::AmberTraj::what
        
            typedef char const * ( ::SireIO::AmberTraj::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireIO::AmberTraj::what );
            
            AmberTraj_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireIO::AmberTraj::writeToFile
        
            typedef ::QStringList ( ::SireIO::AmberTraj::*writeToFile_function_type)( ::QString const & ) const;
            writeToFile_function_type writeToFile_function_value( &::SireIO::AmberTraj::writeToFile );
            
            AmberTraj_exposer.def( 
                "writeToFile"
                , writeToFile_function_value
                , ( bp::arg("filename") )
                , bp::release_gil_policy()
                , "Write this to the file filename" );
        
        }
        AmberTraj_exposer.staticmethod( "parse" );
        AmberTraj_exposer.staticmethod( "typeName" );
        AmberTraj_exposer.def( "__copy__", &__copy__<SireIO::AmberTraj>);
        AmberTraj_exposer.def( "__deepcopy__", &__copy__<SireIO::AmberTraj>);
        AmberTraj_exposer.def( "clone", &__copy__<SireIO::AmberTraj>);
        AmberTraj_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireIO::AmberTraj >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AmberTraj_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireIO::AmberTraj >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AmberTraj_exposer.def_pickle(sire_pickle_suite< ::SireIO::AmberTraj >());
        AmberTraj_exposer.def( "__str__", &__str__< ::SireIO::AmberTraj > );
        AmberTraj_exposer.def( "__repr__", &__str__< ::SireIO::AmberTraj > );
    }

}
