
function(check_and_fix_lto_library)
    if(NOT APPLE)
        message(STATUS "Not on MacOS, skipping LTO check")
        return()
    endif()

    # do we have clang++ somewhere in CMAKE_CXX_COMPILER?
    if(NOT CMAKE_CXX_COMPILER MATCHES "clang")
        message(STATUS "CMAKE_CXX_COMPILER is not using Clang, skipping LTO check")
        return()
    endif()

    # Check if ANACONDA_BASE is set
    if(NOT DEFINED ANACONDA_BASE OR ANACONDA_BASE STREQUAL "")
        message(WARNING "ANACONDA_BASE - skipping LTO check")
        return()
    endif()

    message(STATUS "Checking for LTO library naming issues for clang++ in ${ANACONDA_BASE} on MacOS")

    # Check if we're using a conda environment
    set(COMPILER_DIR ${ANACONDA_BASE}/bin)

    # Create a simple test program
    set(TEST_SOURCE "${CMAKE_BINARY_DIR}/lto_test.cpp")
    file(WRITE ${TEST_SOURCE} "int main() { return 0; }")

    # Try to compile and link with verbose output
    execute_process(
        COMMAND ${CMAKE_CXX_COMPILER} --verbose ${TEST_SOURCE} -o ${CMAKE_BINARY_DIR}/lto_test
        RESULT_VARIABLE COMPILE_RESULT
        OUTPUT_VARIABLE COMPILE_OUTPUT
        ERROR_VARIABLE COMPILE_ERROR
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    )

    # Clean up test files
    file(REMOVE ${TEST_SOURCE})
    file(REMOVE ${CMAKE_BINARY_DIR}/lto_test)

    # Check if we got the specific LTO library error
    if(COMPILE_RESULT EQUAL 0)
        message(STATUS "LTO library check: PASSED - No fix needed")
        return()
    endif()

    if(COMPILE_ERROR MATCHES "lto_library library filename must be 'libLTO.dylib'")
        message(STATUS "LTO library check: FAILED - Fix required")

        # Extract the library directory from compiler path
        set(LIB_DIR "${ANACONDA_BASE}/lib")

        # Check if libLTO.dylib already exists (maybe from previous run)
        if(EXISTS "${LIB_DIR}/libLTO.dylib")
            message(STATUS "libLTO.dylib already exists, checking if linker wrapper is needed...")
        endif()

        # Create the linker wrapper script
        set(LD_WRAPPER "${COMPILER_DIR}/ld")

        # Check if wrapper already exists and is up to date
        set(WRAPPER_NEEDED TRUE)
        if(EXISTS ${LD_WRAPPER})
            file(READ ${LD_WRAPPER} EXISTING_WRAPPER)
            if(EXISTING_WRAPPER MATCHES "libLTO.*dylib.*libLTO.dylib")
                message(STATUS "Linker wrapper already exists and appears correct")
                set(WRAPPER_NEEDED FALSE)
            endif()
        endif()

        if(WRAPPER_NEEDED)
            message(STATUS "Creating linker wrapper script at: ${LD_WRAPPER}")

            # Create the wrapper script
            file(WRITE ${LD_WRAPPER} "#!/bin/bash\n")
            file(APPEND ${LD_WRAPPER} "# Auto-generated by CMake to fix LTO library naming issue\n")
            file(APPEND ${LD_WRAPPER} "# Replace versioned LTO library with unversioned one\n")
            file(APPEND ${LD_WRAPPER} "args=()\n")
            file(APPEND ${LD_WRAPPER} "for arg in \"$@\"; do\n")
            file(APPEND ${LD_WRAPPER} "    if [[ \"$arg\" == */libLTO.*.dylib ]]; then\n")
            file(APPEND ${LD_WRAPPER} "        args+=(\"$\{arg%/*}/libLTO.dylib\")\n")
            file(APPEND ${LD_WRAPPER} "    else\n")
            file(APPEND ${LD_WRAPPER} "        args+=(\"$arg\")\n")
            file(APPEND ${LD_WRAPPER} "    fi\n")
            file(APPEND ${LD_WRAPPER} "done\n")
            file(APPEND ${LD_WRAPPER} "exec /usr/bin/ld \"$\{args[@]}\"\n")

            # Make it executable
            execute_process(
                COMMAND chmod +x ${LD_WRAPPER}
                RESULT_VARIABLE CHMOD_RESULT
            )

            if(NOT CHMOD_RESULT EQUAL 0)
                message(WARNING "Failed to make linker wrapper executable")
                return()
            endif()
        endif()

        # Also create the unversioned libLTO.dylib symlink as backup
        file(GLOB LTO_LIBS "${LIB_DIR}/libLTO.*.dylib")
        if(LTO_LIBS AND NOT EXISTS "${LIB_DIR}/libLTO.dylib")
            # Find the highest version number
            set(LATEST_LTO "")
            set(LATEST_VERSION "0")
            foreach(LTO_LIB ${LTO_LIBS})
                get_filename_component(LTO_NAME ${LTO_LIB} NAME)
                if(LTO_NAME MATCHES "libLTO\\.([0-9]+)\\.([0-9]+)\\.dylib")
                    set(MAJOR ${CMAKE_MATCH_1})
                    set(MINOR ${CMAKE_MATCH_2})
                    math(EXPR VERSION_NUM "${MAJOR} * 100 + ${MINOR}")
                    if(VERSION_NUM GREATER LATEST_VERSION)
                        set(LATEST_VERSION ${VERSION_NUM})
                        set(LATEST_LTO ${LTO_LIB})
                    endif()
                endif()
            endforeach()

            if(LATEST_LTO)
                get_filename_component(LATEST_NAME ${LATEST_LTO} NAME)
                message(STATUS "Creating symlink: libLTO.dylib -> ${LATEST_NAME}")
                execute_process(
                    COMMAND ln -sf ${LATEST_NAME} libLTO.dylib
                    WORKING_DIRECTORY ${LIB_DIR}
                )
            endif()
        endif()

        # Test the fix
        message(STATUS "Testing the fix...")
        file(WRITE ${TEST_SOURCE} "int main() { return 0; }")

        execute_process(
            COMMAND ${CMAKE_CXX_COMPILER} ${TEST_SOURCE} -o ${CMAKE_BINARY_DIR}/lto_test_fixed
            RESULT_VARIABLE TEST_RESULT
            OUTPUT_QUIET
            WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        )

        file(REMOVE ${CMAKE_BINARY_DIR}/lto_test_fixed)
        file(REMOVE ${TEST_SOURCE})

        if(TEST_RESULT EQUAL 0)
            message(STATUS "LTO fix verification: SUCCESS")
        else()
            message(WARNING "LTO fix verification: FAILED - Manual intervention may be required")
        endif()

    else()
        message(STATUS "LTO library check: Different compilation error (not LTO-related)")
    endif()
endfunction()

